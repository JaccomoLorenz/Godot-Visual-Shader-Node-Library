[gd_scene load_steps=152 format=2]

[ext_resource path="res://addons/visual_shader_node_library/examples/2D/icon.png" type="Texture" id=1]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/rotation_3d.gd" type="Script" id=2]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/rotation_2d.gd" type="Script" id=3]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/perlin_4d.gd" type="Script" id=4]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/perlin_3d.gd" type="Script" id=5]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/perlin_2d.gd" type="Script" id=6]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/random.gd" type="Script" id=7]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/cellular_2d.gd" type="Script" id=8]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/cellular_2d_2x2.gd" type="Script" id=9]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/cellular_3d.gd" type="Script" id=10]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/cellular_3d_2x2x2.gd" type="Script" id=11]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/simplex_2d_rg.gd" type="Script" id=12]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/simplex_3d.gd" type="Script" id=13]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/simplex_4d.gd" type="Script" id=14]

[sub_resource type="VisualShaderNodeCustom" id=1]
script = ExtResource( 3 )

[sub_resource type="VisualShaderNodeInput" id=2]
input_name = "vertex"

[sub_resource type="VisualShaderNodeInput" id=3]
input_name = "time"

[sub_resource type="VisualShaderNodeScalarConstant" id=4]
constant = 45.0

[sub_resource type="VisualShaderNodeScalarFunc" id=5]
function = 27

[sub_resource type="VisualShader" id=6]
code = "shader_type canvas_item;


// Rotation2D

void rotation_2d(float angle, vec3 pivot, in vec3 position_in,  out vec3 position_out) {
	mat2 rotation_matrix = mat2( vec2(cos(angle), -sin(angle)), vec2(sin(angle), cos(angle)));
	position_in -= pivot;
	position_out.xy = rotation_matrix * position_in.xy;
	position_out.z = position_in.z;
	position_out += pivot;
	
}

void vertex() {
// Input:4
	float n_out4p0 = TIME;

// Input:3
	vec3 n_out3p0 = vec3(VERTEX, 0.0);

// Rotation2D:2
	vec3 n_out2p0;
	{
		rotation_2d(n_out4p0, vec3(0.0, 0.0, 0.0), n_out3p0, n_out2p0);
	}

// Output:0
	VERTEX = n_out2p0.xy;

}

void fragment() {
// Output:0

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -606, -85 )
mode = 1
flags/light_only = false
nodes/vertex/0/position = Vector2( 260, 140 )
nodes/vertex/2/node = SubResource( 1 )
nodes/vertex/2/position = Vector2( 20, 140 )
nodes/vertex/3/node = SubResource( 2 )
nodes/vertex/3/position = Vector2( -200, 240 )
nodes/vertex/4/node = SubResource( 3 )
nodes/vertex/4/position = Vector2( -200, 60 )
nodes/vertex/5/node = SubResource( 4 )
nodes/vertex/5/position = Vector2( -420, 160 )
nodes/vertex/6/node = SubResource( 5 )
nodes/vertex/6/position = Vector2( -220, 160 )
nodes/vertex/connections = PoolIntArray( 3, 0, 2, 2, 2, 0, 0, 0, 5, 0, 6, 0, 4, 0, 2, 0 )

[sub_resource type="ShaderMaterial" id=7]
shader = SubResource( 6 )

[sub_resource type="VisualShaderNodeCustom" id=8]
default_input_values = [ 1, 0.0 ]
script = ExtResource( 2 )

[sub_resource type="VisualShaderNodeVec3Constant" id=9]
constant = Vector3( 1, 1, 1 )

[sub_resource type="VisualShaderNodeGlobalExpression" id=10]
size = Vector2( 464, 132 )
expression = "/*Rotation3D can also be used in Canvas Item*/

"

[sub_resource type="VisualShader" id=11]
code = "shader_type canvas_item;


// Rotation3D

mat4 rotation_matrix_3d(vec3 axis, float angle){
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(vec4(oc * axis.x * axis.x + c,			oc * axis.x * axis.y - axis.z * s,	oc * axis.z * axis.x + axis.y * s,	0.0),
                vec4(oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,			oc * axis.y * axis.z - axis.x * s,	0.0),
                vec4(oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, 	oc * axis.z * axis.z + c,			0.0),
                vec4(0.0,								0.0, 								0.0,								1.0));
}

void rotation_3d_normal(vec3 axis, float angle, in vec3 normal_in, out vec3 normal_out) {
	normal_out = (rotation_matrix_3d(axis, angle) * vec4(normal_in, 0.0)).xyz;
}

void rotation_3d(vec3 axis, float angle, vec3 pivot, in vec3 position_in, out vec3 position_out) {
	position_in.xyz -= pivot;
	vec4 position = vec4(position_in, 1.0);
	position_out = (rotation_matrix_3d(axis, angle) * position).xyz;
	position_out += pivot;
}
// GlobalExpression:0
	/*Rotation3D can also be used in Canvas Item*/
	
	

void vertex() {
// Vector:8
	vec3 n_out8p0 = vec3(1.000000, 1.000000, 1.000000);

// Input:4
	float n_out4p0 = TIME;

// Input:3
	vec3 n_out3p0 = vec3(VERTEX, 0.0);

// Rotation3D:7
	vec3 n_out7p0;
	vec3 n_out7p1;
	{
		rotation_3d(n_out8p0, n_out4p0, vec3(0.0, 0.0, 0.0), n_out3p0, n_out7p0);n_out7p1 = vec3(0.0, 0.0, 0.0);
	}

// Output:0
	VERTEX = n_out7p0.xy;

}

void fragment() {
// Output:0

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -519, -103 )
mode = 1
flags/light_only = false
nodes/vertex/0/position = Vector2( 260, 140 )
nodes/vertex/3/node = SubResource( 2 )
nodes/vertex/3/position = Vector2( -200, 240 )
nodes/vertex/4/node = SubResource( 3 )
nodes/vertex/4/position = Vector2( -200, 100 )
nodes/vertex/5/node = SubResource( 4 )
nodes/vertex/5/position = Vector2( -420, 160 )
nodes/vertex/6/node = SubResource( 5 )
nodes/vertex/6/position = Vector2( -220, 160 )
nodes/vertex/7/node = SubResource( 8 )
nodes/vertex/7/position = Vector2( 40, 140 )
nodes/vertex/8/node = SubResource( 9 )
nodes/vertex/8/position = Vector2( -340, 0 )
nodes/vertex/9/node = SubResource( 10 )
nodes/vertex/9/position = Vector2( 20, -40 )
nodes/vertex/9/size = Vector2( 464, 132 )
nodes/vertex/9/input_ports = ""
nodes/vertex/9/output_ports = ""
nodes/vertex/9/expression = "/*Rotation3D can also be used in Canvas Item*/

"
nodes/vertex/connections = PoolIntArray( 5, 0, 6, 0, 7, 0, 0, 0, 3, 0, 7, 3, 4, 0, 7, 1, 8, 0, 7, 0 )

[sub_resource type="ShaderMaterial" id=12]
shader = SubResource( 11 )

[sub_resource type="VisualShaderNodeInput" id=13]
input_name = "uv"

[sub_resource type="VisualShaderNodeCustom" id=165]
default_input_values = [ 2, Vector3( 10, 10, 1 ) ]
script = ExtResource( 6 )

[sub_resource type="VisualShader" id=16]
code = "shader_type canvas_item;


// PerlinNoise2D


// GLSL textureless classic 2D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec4 HELPER_PerlinNoise2D_mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise2D_permute(vec4 x) {
    return HELPER_PerlinNoise2D_mod289(((x * 34.0) + 1.0) * x);
}

vec4 HELPER_PerlinNoise2D_taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec2 HELPER_PerlinNoise2D_fade(vec2 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_2d_np(vec2 P) {
    vec4 Pi = floor(vec4(P, P)) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(vec4(P, P)) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = HELPER_PerlinNoise2D_mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = HELPER_PerlinNoise2D_permute(HELPER_PerlinNoise2D_permute(ix) + iy);

    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;

    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);
    
    vec4 norm = HELPER_PerlinNoise2D_taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;
    
    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));
    
    vec2 fade_xy = HELPER_PerlinNoise2D_fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 1.15 * n_xy + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_2d_p(vec2 P, vec2 rep) {
    vec4 Pi = floor(vec4(P, P)) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(vec4(P, P)) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod(Pi, vec4(rep, rep)); // To create noise with explicit period
    Pi = HELPER_PerlinNoise2D_mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;
    
    vec4 i = HELPER_PerlinNoise2D_permute(HELPER_PerlinNoise2D_permute(ix) + iy);
    
    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;
    
    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);
    
    vec4 norm = HELPER_PerlinNoise2D_taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;

    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));
    
    vec2 fade_xy = HELPER_PerlinNoise2D_fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 1.15 * n_xy + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// PerlinNoise2D:6
	vec3 n_in6p2 = vec3(10.00000, 10.00000, 1.00000);
	float n_out6p0;
	{
		n_out6p0 = perlin_noise_2d_np(((n_out3p0).xy).xy * (n_in6p2).xy.xy);
	}

// Output:0
	COLOR.rgb = vec3(n_out6p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -462.74, 48.78 )
mode = 1
flags/light_only = false
nodes/fragment/3/node = SubResource( 13 )
nodes/fragment/3/position = Vector2( -40, 160 )
nodes/fragment/6/node = SubResource( 165 )
nodes/fragment/6/position = Vector2( 180, 160 )
nodes/fragment/connections = PoolIntArray( 3, 0, 6, 0, 6, 0, 0, 0 )

[sub_resource type="ShaderMaterial" id=17]
shader = SubResource( 16 )

[sub_resource type="VisualShaderNodeInput" id=19]
input_name = "uv"

[sub_resource type="VisualShaderNodeVec3Constant" id=21]
constant = Vector3( 5, 2, 0 )

[sub_resource type="VisualShaderNodeCustom" id=169]
default_input_values = [ 2, Vector3( 10, 10, 10 ) ]
script = ExtResource( 6 )

[sub_resource type="VisualShader" id=22]
code = "shader_type canvas_item;


// PerlinNoise2D


// GLSL textureless classic 2D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec4 HELPER_PerlinNoise2D_mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise2D_permute(vec4 x) {
    return HELPER_PerlinNoise2D_mod289(((x * 34.0) + 1.0) * x);
}

vec4 HELPER_PerlinNoise2D_taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec2 HELPER_PerlinNoise2D_fade(vec2 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_2d_np(vec2 P) {
    vec4 Pi = floor(vec4(P, P)) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(vec4(P, P)) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = HELPER_PerlinNoise2D_mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = HELPER_PerlinNoise2D_permute(HELPER_PerlinNoise2D_permute(ix) + iy);

    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;

    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);
    
    vec4 norm = HELPER_PerlinNoise2D_taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;
    
    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));
    
    vec2 fade_xy = HELPER_PerlinNoise2D_fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 1.15 * n_xy + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_2d_p(vec2 P, vec2 rep) {
    vec4 Pi = floor(vec4(P, P)) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(vec4(P, P)) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod(Pi, vec4(rep, rep)); // To create noise with explicit period
    Pi = HELPER_PerlinNoise2D_mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;
    
    vec4 i = HELPER_PerlinNoise2D_permute(HELPER_PerlinNoise2D_permute(ix) + iy);
    
    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;
    
    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);
    
    vec4 norm = HELPER_PerlinNoise2D_taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;

    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));
    
    vec2 fade_xy = HELPER_PerlinNoise2D_fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 1.15 * n_xy + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// Vector:5
	vec3 n_out5p0 = vec3(5.000000, 2.000000, 0.000000);

// PerlinNoise2D:6
	vec3 n_in6p2 = vec3(10.00000, 10.00000, 10.00000);
	float n_out6p0;
	{
		n_out6p0 = perlin_noise_2d_p(((n_out3p0).xy).xy * (n_in6p2).xy.xy, (n_out5p0).xy);
	}

// Output:0
	COLOR.rgb = vec3(n_out6p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -644.74, -24.22 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 260, 120 )
nodes/fragment/3/node = SubResource( 19 )
nodes/fragment/3/position = Vector2( -140, 60 )
nodes/fragment/5/node = SubResource( 21 )
nodes/fragment/5/position = Vector2( -320, 160 )
nodes/fragment/6/node = SubResource( 169 )
nodes/fragment/6/position = Vector2( 40, 120 )
nodes/fragment/connections = PoolIntArray( 3, 0, 6, 0, 5, 0, 6, 1, 6, 0, 0, 0 )

[sub_resource type="ShaderMaterial" id=23]
shader = SubResource( 22 )

[sub_resource type="VisualShaderNodeCustom" id=166]
default_input_values = [ 2, Vector3( 5, 5, 1 ) ]
script = ExtResource( 5 )

[sub_resource type="VisualShaderNodeCustom" id=167]
default_input_values = [ 2, Vector3( 12, 12, 3 ) ]
script = ExtResource( 5 )

[sub_resource type="VisualShaderNodeVectorCompose" id=28]

[sub_resource type="VisualShaderNodeInput" id=29]
input_name = "uv"

[sub_resource type="VisualShaderNodeVectorCompose" id=30]

[sub_resource type="VisualShaderNodeVectorDecompose" id=31]

[sub_resource type="VisualShaderNodeInput" id=32]
input_name = "time"

[sub_resource type="VisualShader" id=33]
code = "shader_type canvas_item;


// PerlinNoise3D

// GLSL textureless classic 3D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec3 HELPER_PerlinNoise3D_mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise3D_mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise3D_permute(vec4 x) {
    return HELPER_PerlinNoise3D_mod289_4(((x*34.0)+1.0)*x);
}

vec4 HELPER_PerlinNoise3D_taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 HELPER_PerlinNoise3D_fade(vec3 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_3d_np(vec3 P) {
    vec3 Pi0 = floor(P); // Integer part for indexing
    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
    Pi0 = HELPER_PerlinNoise3D_mod289_3(Pi0);
    Pi1 = HELPER_PerlinNoise3D_mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = HELPER_PerlinNoise3D_permute(HELPER_PerlinNoise3D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise3D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise3D_permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = HELPER_PerlinNoise3D_fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_3d_p(vec3 P, vec3 rep) {
    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
    Pi0 = HELPER_PerlinNoise3D_mod289_3(Pi0);
    Pi1 = HELPER_PerlinNoise3D_mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = HELPER_PerlinNoise3D_permute(HELPER_PerlinNoise3D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise3D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise3D_permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = HELPER_PerlinNoise3D_fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// VectorDecompose:7
	float n_out7p0 = n_out4p0.x;
	float n_out7p1 = n_out4p0.y;
	float n_out7p2 = n_out4p0.z;

// Input:8
	float n_out8p0 = TIME;

// VectorCompose:6
	vec3 n_out6p0 = vec3(n_out7p0, n_out7p1, n_out8p0);

// PerlinNoise3D:18
	vec3 n_in18p2 = vec3(5.00000, 5.00000, 1.00000);
	float n_out18p0;
	{
		n_out18p0 = perlin_noise_3d_np(n_out6p0 * n_in18p2);
	}

// PerlinNoise3D:19
	vec3 n_in19p2 = vec3(12.00000, 12.00000, 3.00000);
	float n_out19p0;
	{
		n_out19p0 = perlin_noise_3d_np(n_out6p0 * n_in19p2);
	}

// VectorCompose:3
	float n_in3p1 = 0.00000;
	vec3 n_out3p0 = vec3(n_out18p0, n_in3p1, n_out19p0);

// Output:0
	COLOR.rgb = n_out3p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -422.74, -78.22 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 580, 100 )
nodes/fragment/3/node = SubResource( 28 )
nodes/fragment/3/position = Vector2( 360, 100 )
nodes/fragment/4/node = SubResource( 29 )
nodes/fragment/4/position = Vector2( -560, 80 )
nodes/fragment/6/node = SubResource( 30 )
nodes/fragment/6/position = Vector2( -160, 80 )
nodes/fragment/7/node = SubResource( 31 )
nodes/fragment/7/position = Vector2( -380, 80 )
nodes/fragment/8/node = SubResource( 32 )
nodes/fragment/8/position = Vector2( -380, 220 )
nodes/fragment/18/node = SubResource( 166 )
nodes/fragment/18/position = Vector2( 142.26, 51.78 )
nodes/fragment/19/node = SubResource( 167 )
nodes/fragment/19/position = Vector2( 140, 200 )
nodes/fragment/connections = PoolIntArray( 3, 0, 0, 0, 7, 0, 6, 0, 7, 1, 6, 1, 8, 0, 6, 2, 4, 0, 7, 0, 19, 0, 3, 2, 18, 0, 3, 0, 6, 0, 18, 0, 6, 0, 19, 0 )

[sub_resource type="ShaderMaterial" id=34]
shader = SubResource( 33 )

[sub_resource type="VisualShaderNodeVec3Constant" id=36]
constant = Vector3( 2, 2, 5 )

[sub_resource type="VisualShaderNodeVectorCompose" id=38]

[sub_resource type="VisualShaderNodeVectorDecompose" id=39]

[sub_resource type="VisualShaderNodeInput" id=40]
input_name = "time"

[sub_resource type="VisualShaderNodeInput" id=41]
input_name = "uv"

[sub_resource type="VisualShaderNodeCustom" id=170]
default_input_values = [ 2, Vector3( 10, 10, 10 ) ]
script = ExtResource( 5 )

[sub_resource type="VisualShader" id=42]
code = "shader_type canvas_item;


// PerlinNoise3D

// GLSL textureless classic 3D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec3 HELPER_PerlinNoise3D_mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise3D_mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise3D_permute(vec4 x) {
    return HELPER_PerlinNoise3D_mod289_4(((x*34.0)+1.0)*x);
}

vec4 HELPER_PerlinNoise3D_taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 HELPER_PerlinNoise3D_fade(vec3 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_3d_np(vec3 P) {
    vec3 Pi0 = floor(P); // Integer part for indexing
    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
    Pi0 = HELPER_PerlinNoise3D_mod289_3(Pi0);
    Pi1 = HELPER_PerlinNoise3D_mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = HELPER_PerlinNoise3D_permute(HELPER_PerlinNoise3D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise3D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise3D_permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = HELPER_PerlinNoise3D_fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_3d_p(vec3 P, vec3 rep) {
    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
    Pi0 = HELPER_PerlinNoise3D_mod289_3(Pi0);
    Pi1 = HELPER_PerlinNoise3D_mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = HELPER_PerlinNoise3D_permute(HELPER_PerlinNoise3D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise3D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise3D_permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = HELPER_PerlinNoise3D_fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:8
	vec3 n_out8p0 = vec3(UV, 0.0);

// VectorDecompose:6
	float n_out6p0 = n_out8p0.x;
	float n_out6p1 = n_out8p0.y;
	float n_out6p2 = n_out8p0.z;

// Input:7
	float n_out7p0 = TIME;

// VectorCompose:5
	vec3 n_out5p0 = vec3(n_out6p0, n_out6p1, n_out7p0);

// Vector:3
	vec3 n_out3p0 = vec3(2.000000, 2.000000, 5.000000);

// PerlinNoise3D:9
	vec3 n_in9p2 = vec3(10.00000, 10.00000, 10.00000);
	float n_out9p0;
	{
		n_out9p0 = perlin_noise_3d_p(n_out5p0 * n_in9p2, n_out3p0);
	}

// Output:0
	COLOR.rgb = vec3(n_out9p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -559.74, -90.22 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 260, 80 )
nodes/fragment/3/node = SubResource( 36 )
nodes/fragment/3/position = Vector2( -360, 180 )
nodes/fragment/5/node = SubResource( 38 )
nodes/fragment/5/position = Vector2( -140, 20 )
nodes/fragment/6/node = SubResource( 39 )
nodes/fragment/6/position = Vector2( -380, -40 )
nodes/fragment/7/node = SubResource( 40 )
nodes/fragment/7/position = Vector2( -380, 100 )
nodes/fragment/8/node = SubResource( 41 )
nodes/fragment/8/position = Vector2( -600, -40 )
nodes/fragment/9/node = SubResource( 170 )
nodes/fragment/9/position = Vector2( 80, 80 )
nodes/fragment/connections = PoolIntArray( 6, 0, 5, 0, 6, 1, 5, 1, 7, 0, 5, 2, 8, 0, 6, 0, 5, 0, 9, 0, 3, 0, 9, 1, 9, 0, 0, 0 )

[sub_resource type="ShaderMaterial" id=43]
shader = SubResource( 42 )

[sub_resource type="VisualShaderNodeInput" id=45]
input_name = "uv"

[sub_resource type="VisualShaderNodeInput" id=47]
input_name = "screen_uv"

[sub_resource type="VisualShaderNodeVectorCompose" id=48]

[sub_resource type="VisualShaderNodeVectorDecompose" id=49]

[sub_resource type="VisualShaderNodeVectorDecompose" id=50]

[sub_resource type="VisualShaderNodeCustom" id=168]
default_input_values = [ 4, Vector3( 10, 10, 10 ), 5, 10.0 ]
script = ExtResource( 4 )

[sub_resource type="VisualShader" id=51]
code = "shader_type canvas_item;


// PerlinNoise4D


// GLSL textureless classic 4D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise

vec4 HELPER_PerlinNoise4D_mod289(vec4 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise4D_permute(vec4 x) {
	return HELPER_PerlinNoise4D_mod289(((x*34.0)+1.0)*x);
}

vec4 HELPER_PerlinNoise4D_taylorInvSqrt(vec4 r) {
	return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 HELPER_PerlinNoise4D_fade(vec4 t) {
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_4d_np(vec4 P) {
    vec4 Pi0 = floor(P); // Integer part for indexing
    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
    Pi0 = HELPER_PerlinNoise4D_mod289(Pi0);
    Pi1 = HELPER_PerlinNoise4D_mod289(Pi1);
    vec4 Pf0 = fract(P); // Fractional part for interpolation
    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.zzzz);
    vec4 iz1 = vec4(Pi1.zzzz);
    vec4 iw0 = vec4(Pi0.wwww);
    vec4 iw1 = vec4(Pi1.wwww);
    
    vec4 ixy = HELPER_PerlinNoise4D_permute(HELPER_PerlinNoise4D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise4D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise4D_permute(ixy + iz1);
    vec4 ixy00 = HELPER_PerlinNoise4D_permute(ixy0 + iw0);
    vec4 ixy01 = HELPER_PerlinNoise4D_permute(ixy0 + iw1);
    vec4 ixy10 = HELPER_PerlinNoise4D_permute(ixy1 + iw0);
    vec4 ixy11 = HELPER_PerlinNoise4D_permute(ixy1 + iw1);
    
    vec4 gx00 = ixy00 * (1.0 / 7.0);
    vec4 gy00 = floor(gx00) * (1.0 / 7.0);
    vec4 gz00 = floor(gy00) * (1.0 / 6.0);
    gx00 = fract(gx00) - 0.5;
    gy00 = fract(gy00) - 0.5;
    gz00 = fract(gz00) - 0.5;
    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
    vec4 sw00 = step(gw00, vec4(0.0));
    gx00 -= sw00 * (step(0.0, gx00) - 0.5);
    gy00 -= sw00 * (step(0.0, gy00) - 0.5);
    
    vec4 gx01 = ixy01 * (1.0 / 7.0);
    vec4 gy01 = floor(gx01) * (1.0 / 7.0);
    vec4 gz01 = floor(gy01) * (1.0 / 6.0);
    gx01 = fract(gx01) - 0.5;
    gy01 = fract(gy01) - 0.5;
    gz01 = fract(gz01) - 0.5;
    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
    vec4 sw01 = step(gw01, vec4(0.0));
    gx01 -= sw01 * (step(0.0, gx01) - 0.5);
    gy01 -= sw01 * (step(0.0, gy01) - 0.5);
    
    vec4 gx10 = ixy10 * (1.0 / 7.0);
    vec4 gy10 = floor(gx10) * (1.0 / 7.0);
    vec4 gz10 = floor(gy10) * (1.0 / 6.0);
    gx10 = fract(gx10) - 0.5;
    gy10 = fract(gy10) - 0.5;
    gz10 = fract(gz10) - 0.5;
    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
    vec4 sw10 = step(gw10, vec4(0.0));
    gx10 -= sw10 * (step(0.0, gx10) - 0.5);
    gy10 -= sw10 * (step(0.0, gy10) - 0.5);
    
    vec4 gx11 = ixy11 * (1.0 / 7.0);
    vec4 gy11 = floor(gx11) * (1.0 / 7.0);
    vec4 gz11 = floor(gy11) * (1.0 / 6.0);
    gx11 = fract(gx11) - 0.5;
    gy11 = fract(gy11) - 0.5;
    gz11 = fract(gz11) - 0.5;
    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
    vec4 sw11 = step(gw11, vec4(0.0));
    gx11 -= sw11 * (step(0.0, gx11) - 0.5);
    gy11 -= sw11 * (step(0.0, gy11) - 0.5);
    
    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
    
    vec4 norm00 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
    g0000 *= norm00.x;
    g0100 *= norm00.y;
    g1000 *= norm00.z;
    g1100 *= norm00.w;
    
    vec4 norm01 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
    g0001 *= norm01.x;
    g0101 *= norm01.y;
    g1001 *= norm01.z;
    g1101 *= norm01.w;
    
    vec4 norm10 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
    g0010 *= norm10.x;
    g0110 *= norm10.y;
    g1010 *= norm10.z;
    g1110 *= norm10.w;
    
    vec4 norm11 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
    g0011 *= norm11.x;
    g0111 *= norm11.y;
    g1011 *= norm11.z;
    g1111 *= norm11.w;
    
    float n0000 = dot(g0000, Pf0);
    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
    float n1111 = dot(g1111, Pf1);
    
    vec4 fade_xyzw = HELPER_PerlinNoise4D_fade(Pf0);
    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
    return 1.1 * n_xyzw + 0.5;
}

// Classic Perlin noise, periodic version
float perlin_noise_4d_p(vec4 P, vec4 rep) {
    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep
    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep
    Pi0 = HELPER_PerlinNoise4D_mod289(Pi0);
    Pi1 = HELPER_PerlinNoise4D_mod289(Pi1);
    vec4 Pf0 = fract(P); // Fractional part for interpolation
    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.zzzz);
    vec4 iz1 = vec4(Pi1.zzzz);
    vec4 iw0 = vec4(Pi0.wwww);
    vec4 iw1 = vec4(Pi1.wwww);
    
    vec4 ixy = HELPER_PerlinNoise4D_permute(HELPER_PerlinNoise4D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise4D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise4D_permute(ixy + iz1);
    vec4 ixy00 = HELPER_PerlinNoise4D_permute(ixy0 + iw0);
    vec4 ixy01 = HELPER_PerlinNoise4D_permute(ixy0 + iw1);
    vec4 ixy10 = HELPER_PerlinNoise4D_permute(ixy1 + iw0);
    vec4 ixy11 = HELPER_PerlinNoise4D_permute(ixy1 + iw1);
    
    vec4 gx00 = ixy00 * (1.0 / 7.0);
    vec4 gy00 = floor(gx00) * (1.0 / 7.0);
    vec4 gz00 = floor(gy00) * (1.0 / 6.0);
    gx00 = fract(gx00) - 0.5;
    gy00 = fract(gy00) - 0.5;
    gz00 = fract(gz00) - 0.5;
    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
    vec4 sw00 = step(gw00, vec4(0.0));
    gx00 -= sw00 * (step(0.0, gx00) - 0.5);
    gy00 -= sw00 * (step(0.0, gy00) - 0.5);
    
    vec4 gx01 = ixy01 * (1.0 / 7.0);
    vec4 gy01 = floor(gx01) * (1.0 / 7.0);
    vec4 gz01 = floor(gy01) * (1.0 / 6.0);
    gx01 = fract(gx01) - 0.5;
    gy01 = fract(gy01) - 0.5;
    gz01 = fract(gz01) - 0.5;
    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
    vec4 sw01 = step(gw01, vec4(0.0));
    gx01 -= sw01 * (step(0.0, gx01) - 0.5);
    gy01 -= sw01 * (step(0.0, gy01) - 0.5);
    
    vec4 gx10 = ixy10 * (1.0 / 7.0);
    vec4 gy10 = floor(gx10) * (1.0 / 7.0);
    vec4 gz10 = floor(gy10) * (1.0 / 6.0);
    gx10 = fract(gx10) - 0.5;
    gy10 = fract(gy10) - 0.5;
    gz10 = fract(gz10) - 0.5;
    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
    vec4 sw10 = step(gw10, vec4(0.0));
    gx10 -= sw10 * (step(0.0, gx10) - 0.5);
    gy10 -= sw10 * (step(0.0, gy10) - 0.5);
    
    vec4 gx11 = ixy11 * (1.0 / 7.0);
    vec4 gy11 = floor(gx11) * (1.0 / 7.0);
    vec4 gz11 = floor(gy11) * (1.0 / 6.0);
    gx11 = fract(gx11) - 0.5;
    gy11 = fract(gy11) - 0.5;
    gz11 = fract(gz11) - 0.5;
    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
    vec4 sw11 = step(gw11, vec4(0.0));
    gx11 -= sw11 * (step(0.0, gx11) - 0.5);
    gy11 -= sw11 * (step(0.0, gy11) - 0.5);
    
    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
    
    vec4 norm00 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
    g0000 *= norm00.x;
    g0100 *= norm00.y;
    g1000 *= norm00.z;
    g1100 *= norm00.w;
    
    vec4 norm01 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
    g0001 *= norm01.x;
    g0101 *= norm01.y;
    g1001 *= norm01.z;
    g1101 *= norm01.w;
    
    vec4 norm10 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
    g0010 *= norm10.x;
    g0110 *= norm10.y;
    g1010 *= norm10.z;
    g1110 *= norm10.w;
    
    vec4 norm11 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
    g0011 *= norm11.x;
    g0111 *= norm11.y;
    g1011 *= norm11.z;
    g1111 *= norm11.w;
    
    float n0000 = dot(g0000, Pf0);
    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
    float n1111 = dot(g1111, Pf1);
    
    vec4 fade_xyzw = HELPER_PerlinNoise4D_fade(Pf0);
    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
    return 1.1 * n_xyzw + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// VectorDecompose:7
	float n_out7p0 = n_out3p0.x;
	float n_out7p1 = n_out3p0.y;
	float n_out7p2 = n_out3p0.z;

// Input:5
	vec3 n_out5p0 = vec3(SCREEN_UV, 0.0);

// VectorDecompose:8
	float n_out8p0 = n_out5p0.x;
	float n_out8p1 = n_out5p0.y;
	float n_out8p2 = n_out5p0.z;

// VectorCompose:6
	vec3 n_out6p0 = vec3(n_out7p0, n_out7p1, n_out8p0);

// PerlinNoise4D:9
	vec3 n_in9p4 = vec3(10.00000, 10.00000, 10.00000);
	float n_in9p5 = 10.00000;
	float n_out9p0;
	{
		n_out9p0 = perlin_noise_4d_np(vec4(n_out6p0, n_out8p1) * vec4(n_in9p4, n_in9p5));
	}

// Output:0
	COLOR.rgb = vec3(n_out9p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -553.74, -6.22002 )
mode = 1
flags/light_only = false
nodes/fragment/3/node = SubResource( 45 )
nodes/fragment/3/position = Vector2( -520, 40 )
nodes/fragment/5/node = SubResource( 47 )
nodes/fragment/5/position = Vector2( -580, 160 )
nodes/fragment/6/node = SubResource( 48 )
nodes/fragment/6/position = Vector2( -60, 60 )
nodes/fragment/7/node = SubResource( 49 )
nodes/fragment/7/position = Vector2( -340, 40 )
nodes/fragment/8/node = SubResource( 50 )
nodes/fragment/8/position = Vector2( -340, 160 )
nodes/fragment/9/node = SubResource( 168 )
nodes/fragment/9/position = Vector2( 180, 120 )
nodes/fragment/connections = PoolIntArray( 3, 0, 7, 0, 7, 0, 6, 0, 7, 1, 6, 1, 5, 0, 8, 0, 8, 0, 6, 2, 9, 0, 0, 0, 6, 0, 9, 0, 8, 1, 9, 1 )

[sub_resource type="ShaderMaterial" id=52]
shader = SubResource( 51 )

[sub_resource type="VisualShaderNodeCustom" id=171]
default_input_values = [ 4, Vector3( 10, 10, 10 ), 5, 10.0 ]
script = ExtResource( 4 )

[sub_resource type="VisualShaderNodeVectorDecompose" id=54]

[sub_resource type="VisualShaderNodeVectorDecompose" id=55]

[sub_resource type="VisualShaderNodeVectorCompose" id=56]

[sub_resource type="VisualShaderNodeScalarConstant" id=57]
constant = 2.0

[sub_resource type="VisualShaderNodeInput" id=59]
input_name = "uv"

[sub_resource type="VisualShaderNodeInput" id=60]
input_name = "screen_uv"

[sub_resource type="VisualShader" id=61]
code = "shader_type canvas_item;


// PerlinNoise4D


// GLSL textureless classic 4D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise

vec4 HELPER_PerlinNoise4D_mod289(vec4 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise4D_permute(vec4 x) {
	return HELPER_PerlinNoise4D_mod289(((x*34.0)+1.0)*x);
}

vec4 HELPER_PerlinNoise4D_taylorInvSqrt(vec4 r) {
	return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 HELPER_PerlinNoise4D_fade(vec4 t) {
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_4d_np(vec4 P) {
    vec4 Pi0 = floor(P); // Integer part for indexing
    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
    Pi0 = HELPER_PerlinNoise4D_mod289(Pi0);
    Pi1 = HELPER_PerlinNoise4D_mod289(Pi1);
    vec4 Pf0 = fract(P); // Fractional part for interpolation
    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.zzzz);
    vec4 iz1 = vec4(Pi1.zzzz);
    vec4 iw0 = vec4(Pi0.wwww);
    vec4 iw1 = vec4(Pi1.wwww);
    
    vec4 ixy = HELPER_PerlinNoise4D_permute(HELPER_PerlinNoise4D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise4D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise4D_permute(ixy + iz1);
    vec4 ixy00 = HELPER_PerlinNoise4D_permute(ixy0 + iw0);
    vec4 ixy01 = HELPER_PerlinNoise4D_permute(ixy0 + iw1);
    vec4 ixy10 = HELPER_PerlinNoise4D_permute(ixy1 + iw0);
    vec4 ixy11 = HELPER_PerlinNoise4D_permute(ixy1 + iw1);
    
    vec4 gx00 = ixy00 * (1.0 / 7.0);
    vec4 gy00 = floor(gx00) * (1.0 / 7.0);
    vec4 gz00 = floor(gy00) * (1.0 / 6.0);
    gx00 = fract(gx00) - 0.5;
    gy00 = fract(gy00) - 0.5;
    gz00 = fract(gz00) - 0.5;
    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
    vec4 sw00 = step(gw00, vec4(0.0));
    gx00 -= sw00 * (step(0.0, gx00) - 0.5);
    gy00 -= sw00 * (step(0.0, gy00) - 0.5);
    
    vec4 gx01 = ixy01 * (1.0 / 7.0);
    vec4 gy01 = floor(gx01) * (1.0 / 7.0);
    vec4 gz01 = floor(gy01) * (1.0 / 6.0);
    gx01 = fract(gx01) - 0.5;
    gy01 = fract(gy01) - 0.5;
    gz01 = fract(gz01) - 0.5;
    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
    vec4 sw01 = step(gw01, vec4(0.0));
    gx01 -= sw01 * (step(0.0, gx01) - 0.5);
    gy01 -= sw01 * (step(0.0, gy01) - 0.5);
    
    vec4 gx10 = ixy10 * (1.0 / 7.0);
    vec4 gy10 = floor(gx10) * (1.0 / 7.0);
    vec4 gz10 = floor(gy10) * (1.0 / 6.0);
    gx10 = fract(gx10) - 0.5;
    gy10 = fract(gy10) - 0.5;
    gz10 = fract(gz10) - 0.5;
    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
    vec4 sw10 = step(gw10, vec4(0.0));
    gx10 -= sw10 * (step(0.0, gx10) - 0.5);
    gy10 -= sw10 * (step(0.0, gy10) - 0.5);
    
    vec4 gx11 = ixy11 * (1.0 / 7.0);
    vec4 gy11 = floor(gx11) * (1.0 / 7.0);
    vec4 gz11 = floor(gy11) * (1.0 / 6.0);
    gx11 = fract(gx11) - 0.5;
    gy11 = fract(gy11) - 0.5;
    gz11 = fract(gz11) - 0.5;
    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
    vec4 sw11 = step(gw11, vec4(0.0));
    gx11 -= sw11 * (step(0.0, gx11) - 0.5);
    gy11 -= sw11 * (step(0.0, gy11) - 0.5);
    
    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
    
    vec4 norm00 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
    g0000 *= norm00.x;
    g0100 *= norm00.y;
    g1000 *= norm00.z;
    g1100 *= norm00.w;
    
    vec4 norm01 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
    g0001 *= norm01.x;
    g0101 *= norm01.y;
    g1001 *= norm01.z;
    g1101 *= norm01.w;
    
    vec4 norm10 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
    g0010 *= norm10.x;
    g0110 *= norm10.y;
    g1010 *= norm10.z;
    g1110 *= norm10.w;
    
    vec4 norm11 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
    g0011 *= norm11.x;
    g0111 *= norm11.y;
    g1011 *= norm11.z;
    g1111 *= norm11.w;
    
    float n0000 = dot(g0000, Pf0);
    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
    float n1111 = dot(g1111, Pf1);
    
    vec4 fade_xyzw = HELPER_PerlinNoise4D_fade(Pf0);
    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
    return 1.1 * n_xyzw + 0.5;
}

// Classic Perlin noise, periodic version
float perlin_noise_4d_p(vec4 P, vec4 rep) {
    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep
    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep
    Pi0 = HELPER_PerlinNoise4D_mod289(Pi0);
    Pi1 = HELPER_PerlinNoise4D_mod289(Pi1);
    vec4 Pf0 = fract(P); // Fractional part for interpolation
    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.zzzz);
    vec4 iz1 = vec4(Pi1.zzzz);
    vec4 iw0 = vec4(Pi0.wwww);
    vec4 iw1 = vec4(Pi1.wwww);
    
    vec4 ixy = HELPER_PerlinNoise4D_permute(HELPER_PerlinNoise4D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise4D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise4D_permute(ixy + iz1);
    vec4 ixy00 = HELPER_PerlinNoise4D_permute(ixy0 + iw0);
    vec4 ixy01 = HELPER_PerlinNoise4D_permute(ixy0 + iw1);
    vec4 ixy10 = HELPER_PerlinNoise4D_permute(ixy1 + iw0);
    vec4 ixy11 = HELPER_PerlinNoise4D_permute(ixy1 + iw1);
    
    vec4 gx00 = ixy00 * (1.0 / 7.0);
    vec4 gy00 = floor(gx00) * (1.0 / 7.0);
    vec4 gz00 = floor(gy00) * (1.0 / 6.0);
    gx00 = fract(gx00) - 0.5;
    gy00 = fract(gy00) - 0.5;
    gz00 = fract(gz00) - 0.5;
    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
    vec4 sw00 = step(gw00, vec4(0.0));
    gx00 -= sw00 * (step(0.0, gx00) - 0.5);
    gy00 -= sw00 * (step(0.0, gy00) - 0.5);
    
    vec4 gx01 = ixy01 * (1.0 / 7.0);
    vec4 gy01 = floor(gx01) * (1.0 / 7.0);
    vec4 gz01 = floor(gy01) * (1.0 / 6.0);
    gx01 = fract(gx01) - 0.5;
    gy01 = fract(gy01) - 0.5;
    gz01 = fract(gz01) - 0.5;
    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
    vec4 sw01 = step(gw01, vec4(0.0));
    gx01 -= sw01 * (step(0.0, gx01) - 0.5);
    gy01 -= sw01 * (step(0.0, gy01) - 0.5);
    
    vec4 gx10 = ixy10 * (1.0 / 7.0);
    vec4 gy10 = floor(gx10) * (1.0 / 7.0);
    vec4 gz10 = floor(gy10) * (1.0 / 6.0);
    gx10 = fract(gx10) - 0.5;
    gy10 = fract(gy10) - 0.5;
    gz10 = fract(gz10) - 0.5;
    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
    vec4 sw10 = step(gw10, vec4(0.0));
    gx10 -= sw10 * (step(0.0, gx10) - 0.5);
    gy10 -= sw10 * (step(0.0, gy10) - 0.5);
    
    vec4 gx11 = ixy11 * (1.0 / 7.0);
    vec4 gy11 = floor(gx11) * (1.0 / 7.0);
    vec4 gz11 = floor(gy11) * (1.0 / 6.0);
    gx11 = fract(gx11) - 0.5;
    gy11 = fract(gy11) - 0.5;
    gz11 = fract(gz11) - 0.5;
    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
    vec4 sw11 = step(gw11, vec4(0.0));
    gx11 -= sw11 * (step(0.0, gx11) - 0.5);
    gy11 -= sw11 * (step(0.0, gy11) - 0.5);
    
    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
    
    vec4 norm00 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
    g0000 *= norm00.x;
    g0100 *= norm00.y;
    g1000 *= norm00.z;
    g1100 *= norm00.w;
    
    vec4 norm01 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
    g0001 *= norm01.x;
    g0101 *= norm01.y;
    g1001 *= norm01.z;
    g1101 *= norm01.w;
    
    vec4 norm10 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
    g0010 *= norm10.x;
    g0110 *= norm10.y;
    g1010 *= norm10.z;
    g1110 *= norm10.w;
    
    vec4 norm11 = HELPER_PerlinNoise4D_taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
    g0011 *= norm11.x;
    g0111 *= norm11.y;
    g1011 *= norm11.z;
    g1111 *= norm11.w;
    
    float n0000 = dot(g0000, Pf0);
    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
    float n1111 = dot(g1111, Pf1);
    
    vec4 fade_xyzw = HELPER_PerlinNoise4D_fade(Pf0);
    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
    return 1.1 * n_xyzw + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:8
	vec3 n_out8p0 = vec3(UV, 0.0);

// VectorDecompose:3
	float n_out3p0 = n_out8p0.x;
	float n_out3p1 = n_out8p0.y;
	float n_out3p2 = n_out8p0.z;

// Input:9
	vec3 n_out9p0 = vec3(SCREEN_UV, 0.0);

// VectorDecompose:4
	float n_out4p0 = n_out9p0.x;
	float n_out4p1 = n_out9p0.y;
	float n_out4p2 = n_out9p0.z;

// VectorCompose:5
	vec3 n_out5p0 = vec3(n_out3p0, n_out3p1, n_out4p0);

// Scalar:6
	float n_out6p0 = 2.000000;

// PerlinNoise4D:10
	vec3 n_in10p4 = vec3(10.00000, 10.00000, 10.00000);
	float n_in10p5 = 10.00000;
	float n_out10p0;
	{
		n_out10p0 = perlin_noise_4d_p(vec4(n_out5p0, n_out4p1) * vec4(n_in10p4, n_in10p5), vec4(vec3(n_out6p0), n_out6p0));
	}

// Output:0
	COLOR.rgb = vec3(n_out10p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -774.74, -32 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 100, 60 )
nodes/fragment/3/node = SubResource( 54 )
nodes/fragment/3/position = Vector2( -520, 60 )
nodes/fragment/4/node = SubResource( 55 )
nodes/fragment/4/position = Vector2( -520, 200 )
nodes/fragment/5/node = SubResource( 56 )
nodes/fragment/5/position = Vector2( -300, 60 )
nodes/fragment/6/node = SubResource( 57 )
nodes/fragment/6/position = Vector2( -300, 200 )
nodes/fragment/8/node = SubResource( 59 )
nodes/fragment/8/position = Vector2( -720, 60 )
nodes/fragment/9/node = SubResource( 60 )
nodes/fragment/9/position = Vector2( -780, 200 )
nodes/fragment/10/node = SubResource( 171 )
nodes/fragment/10/position = Vector2( -100, 60 )
nodes/fragment/connections = PoolIntArray( 3, 0, 5, 0, 3, 1, 5, 1, 4, 0, 5, 2, 8, 0, 3, 0, 9, 0, 4, 0, 6, 0, 10, 2, 6, 0, 10, 3, 5, 0, 10, 0, 4, 1, 10, 1, 10, 0, 0, 0 )

[sub_resource type="ShaderMaterial" id=62]
shader = SubResource( 61 )

[sub_resource type="VisualShaderNodeInput" id=63]
input_name = "uv"

[sub_resource type="VisualShaderNodeInput" id=64]
input_name = "time"

[sub_resource type="VisualShaderNodeScalarInterp" id=65]

[sub_resource type="VisualShaderNodeVectorDecompose" id=66]

[sub_resource type="VisualShaderNodeScalarOp" id=67]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 9

[sub_resource type="VisualShaderNodeCustom" id=155]
script = ExtResource( 7 )

[sub_resource type="VisualShader" id=69]
code = "shader_type canvas_item;


// RandomNoise

	float rand(vec4 co){
		float f = dot(fract(co) + fract(co * 2.32184321231),vec4(129.898,782.33,944.32214932,122.2834234542));
		return fract(sin(f) * 437588.5453);
	}
	

void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// Input:4
	float n_out4p0 = TIME;

// VectorDecompose:7
	float n_out7p0 = n_out3p0.x;
	float n_out7p1 = n_out3p0.y;
	float n_out7p2 = n_out3p0.z;

// ScalarOp:8
	float n_in8p1 = 0.50000;
	float n_out8p0 = step(n_out7p0, n_in8p1);

// ScalarMix:6
	float n_in6p1 = 1.00000;
	float n_out6p0 = mix(n_out4p0, n_in6p1, n_out8p0);

// RandomNoise:9
	float n_out9p0;
	{
		n_out9p0 = rand(vec4(n_out3p0, n_out6p0));
	}

// Output:0
	COLOR.rgb = vec3(n_out9p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -573, 87 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 280, 120 )
nodes/fragment/3/node = SubResource( 63 )
nodes/fragment/3/position = Vector2( -520, 120 )
nodes/fragment/4/node = SubResource( 64 )
nodes/fragment/4/position = Vector2( -320, 200 )
nodes/fragment/6/node = SubResource( 65 )
nodes/fragment/6/position = Vector2( -120, 240 )
nodes/fragment/7/node = SubResource( 66 )
nodes/fragment/7/position = Vector2( -540, 300 )
nodes/fragment/8/node = SubResource( 67 )
nodes/fragment/8/position = Vector2( -320, 280 )
nodes/fragment/9/node = SubResource( 155 )
nodes/fragment/9/position = Vector2( 40, 120 )
nodes/fragment/connections = PoolIntArray( 4, 0, 6, 0, 3, 0, 7, 0, 7, 0, 8, 0, 8, 0, 6, 2, 9, 0, 0, 0, 3, 0, 9, 0, 6, 0, 9, 1 )

[sub_resource type="ShaderMaterial" id=70]
shader = SubResource( 69 )

[sub_resource type="VisualShaderNodeCustom" id=159]
default_input_values = [ 1, Vector3( 10, 10, 1 ), 2, 1.0 ]
script = ExtResource( 8 )

[sub_resource type="VisualShaderNodeInput" id=71]
input_name = "uv"

[sub_resource type="VisualShaderNodeVectorDecompose" id=75]

[sub_resource type="VisualShaderNodeScalarOp" id=76]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 9

[sub_resource type="VisualShaderNodeScalarInterp" id=77]
output_port_for_preview = 0

[sub_resource type="VisualShader" id=78]
code = "shader_type canvas_item;


// CellularNoise2D


// Cellular noise (\"Worley noise\") in 2D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 HELPER_CellularNoise2D_mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 HELPER_CellularNoise2D_mod289_2(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec3 HELPER_CellularNoise2D_mod7(vec3 x) {
    return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 HELPER_CellularNoise2D_permute(vec3 x) {
    return HELPER_CellularNoise2D_mod289_3((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// Standard 3x3 search window for good F1 and F2 values
vec2 cellular_noise_2d(vec2 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float Ko = 0.428571428571; // 3/7

    vec2 Pi = HELPER_CellularNoise2D_mod289_2(floor(P));
    vec2 Pf = fract(P);
    vec3 oi = vec3(-1.0, 0.0, 1.0);
    vec3 of = vec3(-0.5, 0.5, 1.5);
    vec3 px = HELPER_CellularNoise2D_permute(Pi.x + oi);
    vec3 p = HELPER_CellularNoise2D_permute(px.x + Pi.y + oi); // p11, p12, p13
    vec3 ox = fract(p*K) - Ko;
    vec3 oy = HELPER_CellularNoise2D_mod7(floor(p*K))*K - Ko;
    vec3 dx = Pf.x + 0.5 + jitter*ox;
    vec3 dy = Pf.y - of + jitter*oy;
    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared
    p = HELPER_CellularNoise2D_permute(px.y + Pi.y + oi); // p21, p22, p23
    ox = fract(p*K) - Ko;
    oy = HELPER_CellularNoise2D_mod7(floor(p*K))*K - Ko;
    dx = Pf.x - 0.5 + jitter*ox;
    dy = Pf.y - of + jitter*oy;
    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared
    p = HELPER_CellularNoise2D_permute(px.z + Pi.y + oi); // p31, p32, p33
    ox = fract(p*K) - Ko;
    oy = HELPER_CellularNoise2D_mod7(floor(p*K))*K - Ko;
    dx = Pf.x - 1.5 + jitter*ox;
    dy = Pf.y - of + jitter*oy;
    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared
    // Sort out the two smallest distances (F1, F2)
    vec3 d1a = min(d1, d2);
    d2 = max(d1, d2); // Swap to keep candidates for F2
    d2 = min(d2, d3); // neither F1 nor F2 are now in d3
    d1 = min(d1a, d2); // F1 is now in d1
    d2 = max(d1a, d2); // Swap to keep candidates for F2
    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller
    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x
    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz
    d1.y = min(d1.y, d1.z); // nor in  d1.z
    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.
    return sqrt(d1.xy);
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// CellularNoise2D:10
	vec3 n_in10p1 = vec3(10.00000, 10.00000, 1.00000);
	float n_in10p2 = 1.00000;
	vec3 n_out10p0;
	float n_out10p1;
	float n_out10p2;
	{
		
			n_out10p0 = vec3(cellular_noise_2d((n_out3p0).xy * (n_in10p1).xy, n_in10p2), 0.0);
			n_out10p1 = n_out10p0.x;
			n_out10p2 = n_out10p0.y;
			
	}

// VectorDecompose:7
	float n_out7p0 = n_out3p0.x;
	float n_out7p1 = n_out3p0.y;
	float n_out7p2 = n_out3p0.z;

// ScalarOp:8
	float n_in8p1 = 0.50000;
	float n_out8p0 = step(n_out7p0, n_in8p1);

// ScalarMix:9
	float n_out9p0 = mix(n_out10p2, n_out10p1, n_out8p0);

// Output:0
	COLOR.rgb = vec3(n_out9p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -400.74, -58.22 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 580, 120 )
nodes/fragment/3/node = SubResource( 71 )
nodes/fragment/3/position = Vector2( -280, 40 )
nodes/fragment/7/node = SubResource( 75 )
nodes/fragment/7/position = Vector2( -120, -40 )
nodes/fragment/8/node = SubResource( 76 )
nodes/fragment/8/position = Vector2( 100, -40 )
nodes/fragment/9/node = SubResource( 77 )
nodes/fragment/9/position = Vector2( 360, 40 )
nodes/fragment/10/node = SubResource( 159 )
nodes/fragment/10/position = Vector2( 40, 140 )
nodes/fragment/connections = PoolIntArray( 3, 0, 7, 0, 7, 0, 8, 0, 8, 0, 9, 2, 9, 0, 0, 0, 10, 1, 9, 1, 10, 2, 9, 0, 3, 0, 10, 0 )

[sub_resource type="ShaderMaterial" id=79]
shader = SubResource( 78 )

[sub_resource type="VisualShaderNodeScalarInterp" id=80]

[sub_resource type="VisualShaderNodeInput" id=81]
input_name = "uv"

[sub_resource type="VisualShaderNodeVectorDecompose" id=83]

[sub_resource type="VisualShaderNodeScalarOp" id=84]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 9

[sub_resource type="VisualShaderNodeCustom" id=160]
default_input_values = [ 1, Vector3( 10, 10, 1 ), 2, 1.0 ]
script = ExtResource( 9 )

[sub_resource type="VisualShader" id=87]
code = "shader_type canvas_item;


// CellularNoise2D_2X2


// Cellular noise (\\\"Worley noise\\\") in 2D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec2 HELPER_CellularNoise2D_2X2_mod289_2(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_CellularNoise2D_2X2_mod289_4(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec4 HELPER_CellularNoise2D_2X2_mod7(vec4 x) {
  return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec4 HELPER_CellularNoise2D_2X2_permute(vec4 x) {
  return HELPER_CellularNoise2D_2X2_mod289_4((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// Speeded up by using 2x2 search window instead of 3x3,
// at the expense of some strong pattern artifacts.
// F2 is often wrong and has sharp discontinuities.
// If you need a smooth F2, use the slower 3x3 version.
// F1 is sometimes wrong, too, but OK for most purposes.
vec2 cellular_noise_2d_2x2(vec2 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float K2 = 0.0714285714285; // K/2

    vec2 Pi = HELPER_CellularNoise2D_2X2_mod289_2(floor(P));
    vec2 Pf = fract(P);
    vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);
    vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);
    vec4 p = HELPER_CellularNoise2D_2X2_permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));
    p = HELPER_CellularNoise2D_2X2_permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));
    vec4 ox = HELPER_CellularNoise2D_2X2_mod7(p)*K+K2;
    vec4 oy = HELPER_CellularNoise2D_2X2_mod7(floor(p*K))*K+K2;
    vec4 dx = Pfx + jitter*ox;
    vec4 dy = Pfy + jitter*oy;
    vec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared
    // Sort out the two smallest distances

/*// F1 Only Block (works faster of course)
    d.xy = min(d.xy, d.zw);
    d.x = min(d.x, d.y);
    return vec2(sqrt(d.x)); // F1 duplicated, F2 not computed
//*/// End of F1 Only Block

//*// F1 and F2 block
    d.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller
    d.xz = (d.x < d.z) ? d.xz : d.zx;
    d.xw = (d.x < d.w) ? d.xw : d.wx;
    d.y = min(d.y, d.z);
    d.y = min(d.y, d.w);
    return sqrt(d.xy);
//*/// End of F1 and F2 block
}


void vertex() {
// Output:0

}

void fragment() {
// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// CellularNoise2D_2X2:8
	vec3 n_in8p1 = vec3(10.00000, 10.00000, 1.00000);
	float n_in8p2 = 1.00000;
	vec3 n_out8p0;
	float n_out8p1;
	float n_out8p2;
	{
		
			n_out8p0 = vec3(cellular_noise_2d_2x2((n_out4p0).xy * (n_in8p1).xy, n_in8p2), 0.0);
			n_out8p1 = n_out8p0.x;
			n_out8p2 = n_out8p0.y;
			
	}

// VectorDecompose:6
	float n_out6p0 = n_out4p0.x;
	float n_out6p1 = n_out4p0.y;
	float n_out6p2 = n_out4p0.z;

// ScalarOp:7
	float n_in7p1 = 0.50000;
	float n_out7p0 = step(n_out6p0, n_in7p1);

// ScalarMix:3
	float n_out3p0 = mix(n_out8p2, n_out8p1, n_out7p0);

// Output:0
	COLOR.rgb = vec3(n_out3p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -400.74, -58.22 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 840, 60 )
nodes/fragment/3/node = SubResource( 80 )
nodes/fragment/3/position = Vector2( 660, 60 )
nodes/fragment/4/node = SubResource( 81 )
nodes/fragment/4/position = Vector2( 40, 0 )
nodes/fragment/6/node = SubResource( 83 )
nodes/fragment/6/position = Vector2( 240, -40 )
nodes/fragment/7/node = SubResource( 84 )
nodes/fragment/7/position = Vector2( 440, -60 )
nodes/fragment/8/node = SubResource( 160 )
nodes/fragment/8/position = Vector2( 360, 100 )
nodes/fragment/connections = PoolIntArray( 4, 0, 6, 0, 6, 0, 7, 0, 7, 0, 3, 2, 3, 0, 0, 0, 4, 0, 8, 0, 8, 1, 3, 1, 8, 2, 3, 0 )

[sub_resource type="ShaderMaterial" id=88]
shader = SubResource( 87 )

[sub_resource type="VisualShaderNodeVectorCompose" id=89]

[sub_resource type="VisualShaderNodeInput" id=91]
input_name = "time"

[sub_resource type="VisualShaderNodeCustom" id=161]
default_input_values = [ 1, Vector3( 10, 10, 1 ), 2, 1.0 ]
script = ExtResource( 10 )

[sub_resource type="VisualShader" id=93]
code = "shader_type canvas_item;


// CelluarNoise3D


// Cellular noise (\"Worley noise\") in 3D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 HELPER_CelluarNoise3D_mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec3 HELPER_CelluarNoise3D_mod7(vec3 x) {
    return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 HELPER_CelluarNoise3D_permute(vec3 x) {
    return HELPER_CelluarNoise3D_mod289((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// 3x3x3 search region for good F2 everywhere, but a lot
// slower than the 2x2x2 version.
// The code below is a bit scary even to its author,
// but it has at least half decent performance on a
// modern GPU. In any case, it beats any software
// implementation of Worley noise hands down.

vec2 cellular_noise_3d(vec3 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float Ko = 0.428571428571; // 1/2-K/2
    float K2 = 0.020408163265306; // 1/(7*7)
    float Kz = 0.166666666667; // 1/6
    float Kzo = 0.416666666667; // 1/2-1/6*2
    
    vec3 Pi = HELPER_CelluarNoise3D_mod289(floor(P));
    vec3 Pf = fract(P) - 0.5;
    
    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);
    
    vec3 p = HELPER_CelluarNoise3D_permute(Pi.x + vec3(-1.0, 0.0, 1.0));
    vec3 p1 = HELPER_CelluarNoise3D_permute(p + Pi.y - 1.0);
    vec3 p2 = HELPER_CelluarNoise3D_permute(p + Pi.y);
    vec3 p3 = HELPER_CelluarNoise3D_permute(p + Pi.y + 1.0);
    
    vec3 p11 = HELPER_CelluarNoise3D_permute(p1 + Pi.z - 1.0);
    vec3 p12 = HELPER_CelluarNoise3D_permute(p1 + Pi.z);
    vec3 p13 = HELPER_CelluarNoise3D_permute(p1 + Pi.z + 1.0);
    
    vec3 p21 = HELPER_CelluarNoise3D_permute(p2 + Pi.z - 1.0);
    vec3 p22 = HELPER_CelluarNoise3D_permute(p2 + Pi.z);
    vec3 p23 = HELPER_CelluarNoise3D_permute(p2 + Pi.z + 1.0);
    
    vec3 p31 = HELPER_CelluarNoise3D_permute(p3 + Pi.z - 1.0);
    vec3 p32 = HELPER_CelluarNoise3D_permute(p3 + Pi.z);
    vec3 p33 = HELPER_CelluarNoise3D_permute(p3 + Pi.z + 1.0);
    
    vec3 ox11 = fract(p11*K) - Ko;
    vec3 oy11 = HELPER_CelluarNoise3D_mod7(floor(p11*K))*K - Ko;
    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed
    
    vec3 ox12 = fract(p12*K) - Ko;
    vec3 oy12 = HELPER_CelluarNoise3D_mod7(floor(p12*K))*K - Ko;
    vec3 oz12 = floor(p12*K2)*Kz - Kzo;
    
    vec3 ox13 = fract(p13*K) - Ko;
    vec3 oy13 = HELPER_CelluarNoise3D_mod7(floor(p13*K))*K - Ko;
    vec3 oz13 = floor(p13*K2)*Kz - Kzo;
    
    vec3 ox21 = fract(p21*K) - Ko;
    vec3 oy21 = HELPER_CelluarNoise3D_mod7(floor(p21*K))*K - Ko;
    vec3 oz21 = floor(p21*K2)*Kz - Kzo;
    
    vec3 ox22 = fract(p22*K) - Ko;
    vec3 oy22 = HELPER_CelluarNoise3D_mod7(floor(p22*K))*K - Ko;
    vec3 oz22 = floor(p22*K2)*Kz - Kzo;
    
    vec3 ox23 = fract(p23*K) - Ko;
    vec3 oy23 = HELPER_CelluarNoise3D_mod7(floor(p23*K))*K - Ko;
    vec3 oz23 = floor(p23*K2)*Kz - Kzo;
    
    vec3 ox31 = fract(p31*K) - Ko;
    vec3 oy31 = HELPER_CelluarNoise3D_mod7(floor(p31*K))*K - Ko;
    vec3 oz31 = floor(p31*K2)*Kz - Kzo;
    
    vec3 ox32 = fract(p32*K) - Ko;
    vec3 oy32 = HELPER_CelluarNoise3D_mod7(floor(p32*K))*K - Ko;
    vec3 oz32 = floor(p32*K2)*Kz - Kzo;
    
    vec3 ox33 = fract(p33*K) - Ko;
    vec3 oy33 = HELPER_CelluarNoise3D_mod7(floor(p33*K))*K - Ko;
    vec3 oz33 = floor(p33*K2)*Kz - Kzo;
    
    vec3 dx11 = Pfx + jitter*ox11;
    vec3 dy11 = Pfy.x + jitter*oy11;
    vec3 dz11 = Pfz.x + jitter*oz11;
    
    vec3 dx12 = Pfx + jitter*ox12;
    vec3 dy12 = Pfy.x + jitter*oy12;
    vec3 dz12 = Pfz.y + jitter*oz12;
    
    vec3 dx13 = Pfx + jitter*ox13;
    vec3 dy13 = Pfy.x + jitter*oy13;
    vec3 dz13 = Pfz.z + jitter*oz13;
    
    vec3 dx21 = Pfx + jitter*ox21;
    vec3 dy21 = Pfy.y + jitter*oy21;
    vec3 dz21 = Pfz.x + jitter*oz21;
    
    vec3 dx22 = Pfx + jitter*ox22;
    vec3 dy22 = Pfy.y + jitter*oy22;
    vec3 dz22 = Pfz.y + jitter*oz22;
    
    vec3 dx23 = Pfx + jitter*ox23;
    vec3 dy23 = Pfy.y + jitter*oy23;
    vec3 dz23 = Pfz.z + jitter*oz23;
    
    vec3 dx31 = Pfx + jitter*ox31;
    vec3 dy31 = Pfy.z + jitter*oy31;
    vec3 dz31 = Pfz.x + jitter*oz31;
    
    vec3 dx32 = Pfx + jitter*ox32;
    vec3 dy32 = Pfy.z + jitter*oy32;
    vec3 dz32 = Pfz.y + jitter*oz32;
    
    vec3 dx33 = Pfx + jitter*ox33;
    vec3 dy33 = Pfy.z + jitter*oy33;
    vec3 dz33 = Pfz.z + jitter*oz33;
    
    vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;
    vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;
    vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;
    vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;
    vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;
    vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;
    vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;
    vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;
    vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;
    
    // Sort out the two smallest distances (F1, F2)
/*// F1 only block
    vec3 d1 = min(min(d11,d12), d13);
    vec3 d2 = min(min(d21,d22), d23);
    vec3 d3 = min(min(d31,d32), d33);
    vec3 d = min(min(d1,d2), d3);
    d.x = min(min(d.x,d.y),d.z);
    return vec2(sqrt(d.x)); // F1 duplicated, no F2 computed
//*/// End of F1 only block
//*// F1 and F2 block
    vec3 d1a = min(d11, d12);
    d12 = max(d11, d12);
    d11 = min(d1a, d13); // Smallest now not in d12 or d13
    d13 = max(d1a, d13);
    d12 = min(d12, d13); // 2nd smallest now not in d13
    vec3 d2a = min(d21, d22);
    d22 = max(d21, d22);
    d21 = min(d2a, d23); // Smallest now not in d22 or d23
    d23 = max(d2a, d23);
    d22 = min(d22, d23); // 2nd smallest now not in d23
    vec3 d3a = min(d31, d32);
    d32 = max(d31, d32);
    d31 = min(d3a, d33); // Smallest now not in d32 or d33
    d33 = max(d3a, d33);
    d32 = min(d32, d33); // 2nd smallest now not in d33
    vec3 da = min(d11, d21);
    d21 = max(d11, d21);
    d11 = min(da, d31); // Smallest now in d11
    d31 = max(da, d31); // 2nd smallest now not in d31
    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;
    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest
    d12 = min(d12, d21); // 2nd smallest now not in d21
    d12 = min(d12, d22); // nor in d22
    d12 = min(d12, d31); // nor in d31
    d12 = min(d12, d32); // nor in d32
    d11.yz = min(d11.yz,d12.xy); // nor in d12.yz
    d11.y = min(d11.y,d12.z); // Only two more to go
    d11.y = min(d11.y,d11.z); // Done! (Phew!)
    return sqrt(d11.xy); // F1, F2
//*/// End of F1 and F2 block
}


void vertex() {
// Output:0

}

void fragment() {
// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// VectorDecompose:6
	float n_out6p0 = n_out4p0.x;
	float n_out6p1 = n_out4p0.y;
	float n_out6p2 = n_out4p0.z;

// Input:12
	float n_out12p0 = TIME;

// VectorCompose:10
	vec3 n_out10p0 = vec3(n_out6p0, n_out6p1, n_out12p0);

// CelluarNoise3D:13
	vec3 n_in13p1 = vec3(10.00000, 10.00000, 1.00000);
	float n_in13p2 = 1.00000;
	vec3 n_out13p0;
	float n_out13p1;
	float n_out13p2;
	{
		
			n_out13p0 = vec3(cellular_noise_3d(n_out10p0 * n_in13p1, n_in13p2), 0.0);
			n_out13p1 = n_out13p0.x;
			n_out13p2 = n_out13p0.y;
			
	}

// ScalarOp:7
	float n_in7p1 = 0.50000;
	float n_out7p0 = step(n_out6p0, n_in7p1);

// ScalarMix:3
	float n_out3p0 = mix(n_out13p2, n_out13p1, n_out7p0);

// Output:0
	COLOR.rgb = vec3(n_out3p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -231.74, -106.22 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 840, 60 )
nodes/fragment/3/node = SubResource( 80 )
nodes/fragment/3/position = Vector2( 660, 60 )
nodes/fragment/4/node = SubResource( 81 )
nodes/fragment/4/position = Vector2( -140, -20 )
nodes/fragment/6/node = SubResource( 83 )
nodes/fragment/6/position = Vector2( 40, -60 )
nodes/fragment/7/node = SubResource( 84 )
nodes/fragment/7/position = Vector2( 440, -60 )
nodes/fragment/10/node = SubResource( 89 )
nodes/fragment/10/position = Vector2( 140, 80 )
nodes/fragment/12/node = SubResource( 91 )
nodes/fragment/12/position = Vector2( -80, 100 )
nodes/fragment/13/node = SubResource( 161 )
nodes/fragment/13/position = Vector2( 400, 80 )
nodes/fragment/connections = PoolIntArray( 4, 0, 6, 0, 6, 0, 7, 0, 7, 0, 3, 2, 3, 0, 0, 0, 6, 0, 10, 0, 6, 1, 10, 1, 12, 0, 10, 2, 13, 1, 3, 1, 13, 2, 3, 0, 10, 0, 13, 0 )

[sub_resource type="ShaderMaterial" id=94]
shader = SubResource( 93 )

[sub_resource type="VisualShaderNodeCustom" id=162]
default_input_values = [ 1, Vector3( 10, 10, 1 ), 2, 1.0 ]
script = ExtResource( 11 )

[sub_resource type="VisualShader" id=96]
code = "shader_type canvas_item;


// CelluarNoise3D_2x2x2


// Cellular noise (\"Worley noise\") in 3D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 HELPER_CelluarNoise3D_2x2x2_mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_CelluarNoise3D_2x2x2_mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec4 HELPER_CelluarNoise3D_2x2x2_mod7(vec4 x) {
    return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 HELPER_CelluarNoise3D_2x2x2_permute_3(vec3 x) {
    return HELPER_CelluarNoise3D_2x2x2_mod289_3((34.0 * x + 1.0) * x);
}

vec4 HELPER_CelluarNoise3D_2x2x2_permute_4(vec4 x) {
    return HELPER_CelluarNoise3D_2x2x2_mod289_4((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// Speeded up by using 2x2x2 search window instead of 3x3x3,
// at the expense of some pattern artifacts.
// F2 is often wrong and has sharp discontinuities.
// If you need a good F2, use the slower 3x3x3 version.
vec2 cellular_noise_3d_2x2x2(vec3 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float Ko = 0.428571428571; // 1/2-K/2
    float K2 = 0.020408163265306; // 1/(7*7)
    float Kz = 0.166666666667; // 1/6
    float Kzo = 0.416666666667; // 1/2-1/6*2

    vec3 Pi = HELPER_CelluarNoise3D_2x2x2_mod289_3(floor(P));
    vec3 Pf = fract(P);
    vec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);
    vec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);
    vec4 p = HELPER_CelluarNoise3D_2x2x2_permute_4(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));
    p = HELPER_CelluarNoise3D_2x2x2_permute_4(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));
    vec4 p1 = HELPER_CelluarNoise3D_2x2x2_permute_4(p + Pi.z); // z+0
    vec4 p2 = HELPER_CelluarNoise3D_2x2x2_permute_4(p + Pi.z + vec4(1.0)); // z+1
    vec4 ox1 = fract(p1*K) - Ko;
    vec4 oy1 = HELPER_CelluarNoise3D_2x2x2_mod7(floor(p1*K))*K - Ko;
    vec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed
    vec4 ox2 = fract(p2*K) - Ko;
    vec4 oy2 = HELPER_CelluarNoise3D_2x2x2_mod7(floor(p2*K))*K - Ko;
    vec4 oz2 = floor(p2*K2)*Kz - Kzo;
    vec4 dx1 = Pfx + jitter*ox1;
    vec4 dy1 = Pfy + jitter*oy1;
    vec4 dz1 = Pf.z + jitter*oz1;
    vec4 dx2 = Pfx + jitter*ox2;
    vec4 dy2 = Pfy + jitter*oy2;
    vec4 dz2 = Pf.z - 1.0 + jitter*oz2;
    vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0
    vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1

    // Sort out the two smallest distances (F1, F2)
/*// Block for F1 only
    d1 = min(d1, d2);
    d1.xy = min(d1.xy, d1.wz);
    d1.x = min(d1.x, d1.y);
    return vec2(sqrt(d1.x));
//*///End of F1 only block
//*// Block for both F1 and F2
    vec4 d = min(d1,d2); // F1 is now in d
    d2 = max(d1,d2); // Make sure we keep all candidates for F2
    d.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x
    d.xz = (d.x < d.z) ? d.xz : d.zx;
    d.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x
    d.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw
    d.y = min(d.y, d.z); // nor in d.z
    d.y = min(d.y, d.w); // nor in d.w
    d.y = min(d.y, d2.x); // F2 is now in d.y
    return sqrt(d.xy); // F1 and F2
//*/// End Of F1 and F2 block
}


void vertex() {
// Output:0

}

void fragment() {
// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// VectorDecompose:6
	float n_out6p0 = n_out4p0.x;
	float n_out6p1 = n_out4p0.y;
	float n_out6p2 = n_out4p0.z;

// Input:12
	float n_out12p0 = TIME;

// VectorCompose:10
	vec3 n_out10p0 = vec3(n_out6p0, n_out6p1, n_out12p0);

// CelluarNoise3D_2x2x2:13
	vec3 n_in13p1 = vec3(10.00000, 10.00000, 1.00000);
	float n_in13p2 = 1.00000;
	vec3 n_out13p0;
	float n_out13p1;
	float n_out13p2;
	{
		
			n_out13p0 = vec3(cellular_noise_3d_2x2x2(n_out10p0 * n_in13p1, n_in13p2), 0.0);
			n_out13p1 = n_out13p0.x;
			n_out13p2 = n_out13p0.y;
			
	}

// ScalarOp:7
	float n_in7p1 = 0.50000;
	float n_out7p0 = step(n_out6p0, n_in7p1);

// ScalarMix:3
	float n_out3p0 = mix(n_out13p2, n_out13p1, n_out7p0);

// Output:0
	COLOR.rgb = vec3(n_out3p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -253.74, -121.22 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 840, 60 )
nodes/fragment/3/node = SubResource( 80 )
nodes/fragment/3/position = Vector2( 660, 60 )
nodes/fragment/4/node = SubResource( 81 )
nodes/fragment/4/position = Vector2( -140, -20 )
nodes/fragment/6/node = SubResource( 83 )
nodes/fragment/6/position = Vector2( 40, -60 )
nodes/fragment/7/node = SubResource( 84 )
nodes/fragment/7/position = Vector2( 440, -60 )
nodes/fragment/10/node = SubResource( 89 )
nodes/fragment/10/position = Vector2( 140, 80 )
nodes/fragment/12/node = SubResource( 91 )
nodes/fragment/12/position = Vector2( -100, 60 )
nodes/fragment/13/node = SubResource( 162 )
nodes/fragment/13/position = Vector2( 380, 80 )
nodes/fragment/connections = PoolIntArray( 4, 0, 6, 0, 6, 0, 7, 0, 7, 0, 3, 2, 3, 0, 0, 0, 6, 0, 10, 0, 6, 1, 10, 1, 12, 0, 10, 2, 13, 1, 3, 1, 13, 2, 3, 0, 10, 0, 13, 0 )

[sub_resource type="ShaderMaterial" id=97]
shader = SubResource( 96 )

[sub_resource type="VisualShaderNodeCustom" id=99]
script = ExtResource( 7 )

[sub_resource type="VisualShaderNodeScalarOp" id=100]

[sub_resource type="VisualShaderNodeScalarOp" id=101]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 2

[sub_resource type="VisualShaderNodeVectorCompose" id=103]

[sub_resource type="VisualShaderNodeVectorDecompose" id=104]

[sub_resource type="VisualShaderNodeInput" id=105]
input_name = "time"

[sub_resource type="VisualShaderNodeScalarOp" id=106]
default_input_values = [ 0, 0.0, 1, 0.1 ]
operator = 2

[sub_resource type="VisualShaderNodeInput" id=107]
input_name = "uv"

[sub_resource type="VisualShaderNodeScalarOp" id=108]
operator = 1

[sub_resource type="VisualShaderNodeScalarFunc" id=109]
output_port_for_preview = 0
function = 12

[sub_resource type="VisualShaderNodeVectorCompose" id=112]

[sub_resource type="VisualShaderNodeCustom" id=164]
default_input_values = [ 1, Vector3( 10, 10, 1 ), 2, 1.0 ]
script = ExtResource( 10 )

[sub_resource type="VisualShaderNodeCustom" id=172]
default_input_values = [ 2, Vector3( 20, 20, 20 ) ]
script = ExtResource( 5 )

[sub_resource type="VisualShaderNodeScalarInterp" id=113]

[sub_resource type="VisualShaderNodeScalarConstant" id=114]
constant = 10.0

[sub_resource type="VisualShaderNodeScalarOp" id=115]
output_port_for_preview = 0
default_input_values = [ 0, 0.0, 1, 0.05 ]
operator = 9

[sub_resource type="VisualShader" id=116]
code = "shader_type canvas_item;


// PerlinNoise3D

// GLSL textureless classic 3D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec3 HELPER_PerlinNoise3D_mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise3D_mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_PerlinNoise3D_permute(vec4 x) {
    return HELPER_PerlinNoise3D_mod289_4(((x*34.0)+1.0)*x);
}

vec4 HELPER_PerlinNoise3D_taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 HELPER_PerlinNoise3D_fade(vec3 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_3d_np(vec3 P) {
    vec3 Pi0 = floor(P); // Integer part for indexing
    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
    Pi0 = HELPER_PerlinNoise3D_mod289_3(Pi0);
    Pi1 = HELPER_PerlinNoise3D_mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = HELPER_PerlinNoise3D_permute(HELPER_PerlinNoise3D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise3D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise3D_permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = HELPER_PerlinNoise3D_fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_3d_p(vec3 P, vec3 rep) {
    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
    Pi0 = HELPER_PerlinNoise3D_mod289_3(Pi0);
    Pi1 = HELPER_PerlinNoise3D_mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = HELPER_PerlinNoise3D_permute(HELPER_PerlinNoise3D_permute(ix) + iy);
    vec4 ixy0 = HELPER_PerlinNoise3D_permute(ixy + iz0);
    vec4 ixy1 = HELPER_PerlinNoise3D_permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = HELPER_PerlinNoise3D_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = HELPER_PerlinNoise3D_fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}

// RandomNoise

	float rand(vec4 co){
		float f = dot(fract(co) + fract(co * 2.32184321231),vec4(129.898,782.33,944.32214932,122.2834234542));
		return fract(sin(f) * 437588.5453);
	}
	
// CelluarNoise3D


// Cellular noise (\"Worley noise\") in 3D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 HELPER_CelluarNoise3D_mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec3 HELPER_CelluarNoise3D_mod7(vec3 x) {
    return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 HELPER_CelluarNoise3D_permute(vec3 x) {
    return HELPER_CelluarNoise3D_mod289((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// 3x3x3 search region for good F2 everywhere, but a lot
// slower than the 2x2x2 version.
// The code below is a bit scary even to its author,
// but it has at least half decent performance on a
// modern GPU. In any case, it beats any software
// implementation of Worley noise hands down.

vec2 cellular_noise_3d(vec3 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float Ko = 0.428571428571; // 1/2-K/2
    float K2 = 0.020408163265306; // 1/(7*7)
    float Kz = 0.166666666667; // 1/6
    float Kzo = 0.416666666667; // 1/2-1/6*2
    
    vec3 Pi = HELPER_CelluarNoise3D_mod289(floor(P));
    vec3 Pf = fract(P) - 0.5;
    
    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);
    
    vec3 p = HELPER_CelluarNoise3D_permute(Pi.x + vec3(-1.0, 0.0, 1.0));
    vec3 p1 = HELPER_CelluarNoise3D_permute(p + Pi.y - 1.0);
    vec3 p2 = HELPER_CelluarNoise3D_permute(p + Pi.y);
    vec3 p3 = HELPER_CelluarNoise3D_permute(p + Pi.y + 1.0);
    
    vec3 p11 = HELPER_CelluarNoise3D_permute(p1 + Pi.z - 1.0);
    vec3 p12 = HELPER_CelluarNoise3D_permute(p1 + Pi.z);
    vec3 p13 = HELPER_CelluarNoise3D_permute(p1 + Pi.z + 1.0);
    
    vec3 p21 = HELPER_CelluarNoise3D_permute(p2 + Pi.z - 1.0);
    vec3 p22 = HELPER_CelluarNoise3D_permute(p2 + Pi.z);
    vec3 p23 = HELPER_CelluarNoise3D_permute(p2 + Pi.z + 1.0);
    
    vec3 p31 = HELPER_CelluarNoise3D_permute(p3 + Pi.z - 1.0);
    vec3 p32 = HELPER_CelluarNoise3D_permute(p3 + Pi.z);
    vec3 p33 = HELPER_CelluarNoise3D_permute(p3 + Pi.z + 1.0);
    
    vec3 ox11 = fract(p11*K) - Ko;
    vec3 oy11 = HELPER_CelluarNoise3D_mod7(floor(p11*K))*K - Ko;
    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed
    
    vec3 ox12 = fract(p12*K) - Ko;
    vec3 oy12 = HELPER_CelluarNoise3D_mod7(floor(p12*K))*K - Ko;
    vec3 oz12 = floor(p12*K2)*Kz - Kzo;
    
    vec3 ox13 = fract(p13*K) - Ko;
    vec3 oy13 = HELPER_CelluarNoise3D_mod7(floor(p13*K))*K - Ko;
    vec3 oz13 = floor(p13*K2)*Kz - Kzo;
    
    vec3 ox21 = fract(p21*K) - Ko;
    vec3 oy21 = HELPER_CelluarNoise3D_mod7(floor(p21*K))*K - Ko;
    vec3 oz21 = floor(p21*K2)*Kz - Kzo;
    
    vec3 ox22 = fract(p22*K) - Ko;
    vec3 oy22 = HELPER_CelluarNoise3D_mod7(floor(p22*K))*K - Ko;
    vec3 oz22 = floor(p22*K2)*Kz - Kzo;
    
    vec3 ox23 = fract(p23*K) - Ko;
    vec3 oy23 = HELPER_CelluarNoise3D_mod7(floor(p23*K))*K - Ko;
    vec3 oz23 = floor(p23*K2)*Kz - Kzo;
    
    vec3 ox31 = fract(p31*K) - Ko;
    vec3 oy31 = HELPER_CelluarNoise3D_mod7(floor(p31*K))*K - Ko;
    vec3 oz31 = floor(p31*K2)*Kz - Kzo;
    
    vec3 ox32 = fract(p32*K) - Ko;
    vec3 oy32 = HELPER_CelluarNoise3D_mod7(floor(p32*K))*K - Ko;
    vec3 oz32 = floor(p32*K2)*Kz - Kzo;
    
    vec3 ox33 = fract(p33*K) - Ko;
    vec3 oy33 = HELPER_CelluarNoise3D_mod7(floor(p33*K))*K - Ko;
    vec3 oz33 = floor(p33*K2)*Kz - Kzo;
    
    vec3 dx11 = Pfx + jitter*ox11;
    vec3 dy11 = Pfy.x + jitter*oy11;
    vec3 dz11 = Pfz.x + jitter*oz11;
    
    vec3 dx12 = Pfx + jitter*ox12;
    vec3 dy12 = Pfy.x + jitter*oy12;
    vec3 dz12 = Pfz.y + jitter*oz12;
    
    vec3 dx13 = Pfx + jitter*ox13;
    vec3 dy13 = Pfy.x + jitter*oy13;
    vec3 dz13 = Pfz.z + jitter*oz13;
    
    vec3 dx21 = Pfx + jitter*ox21;
    vec3 dy21 = Pfy.y + jitter*oy21;
    vec3 dz21 = Pfz.x + jitter*oz21;
    
    vec3 dx22 = Pfx + jitter*ox22;
    vec3 dy22 = Pfy.y + jitter*oy22;
    vec3 dz22 = Pfz.y + jitter*oz22;
    
    vec3 dx23 = Pfx + jitter*ox23;
    vec3 dy23 = Pfy.y + jitter*oy23;
    vec3 dz23 = Pfz.z + jitter*oz23;
    
    vec3 dx31 = Pfx + jitter*ox31;
    vec3 dy31 = Pfy.z + jitter*oy31;
    vec3 dz31 = Pfz.x + jitter*oz31;
    
    vec3 dx32 = Pfx + jitter*ox32;
    vec3 dy32 = Pfy.z + jitter*oy32;
    vec3 dz32 = Pfz.y + jitter*oz32;
    
    vec3 dx33 = Pfx + jitter*ox33;
    vec3 dy33 = Pfy.z + jitter*oy33;
    vec3 dz33 = Pfz.z + jitter*oz33;
    
    vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;
    vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;
    vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;
    vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;
    vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;
    vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;
    vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;
    vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;
    vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;
    
    // Sort out the two smallest distances (F1, F2)
/*// F1 only block
    vec3 d1 = min(min(d11,d12), d13);
    vec3 d2 = min(min(d21,d22), d23);
    vec3 d3 = min(min(d31,d32), d33);
    vec3 d = min(min(d1,d2), d3);
    d.x = min(min(d.x,d.y),d.z);
    return vec2(sqrt(d.x)); // F1 duplicated, no F2 computed
//*/// End of F1 only block
//*// F1 and F2 block
    vec3 d1a = min(d11, d12);
    d12 = max(d11, d12);
    d11 = min(d1a, d13); // Smallest now not in d12 or d13
    d13 = max(d1a, d13);
    d12 = min(d12, d13); // 2nd smallest now not in d13
    vec3 d2a = min(d21, d22);
    d22 = max(d21, d22);
    d21 = min(d2a, d23); // Smallest now not in d22 or d23
    d23 = max(d2a, d23);
    d22 = min(d22, d23); // 2nd smallest now not in d23
    vec3 d3a = min(d31, d32);
    d32 = max(d31, d32);
    d31 = min(d3a, d33); // Smallest now not in d32 or d33
    d33 = max(d3a, d33);
    d32 = min(d32, d33); // 2nd smallest now not in d33
    vec3 da = min(d11, d21);
    d21 = max(d11, d21);
    d11 = min(da, d31); // Smallest now in d11
    d31 = max(da, d31); // 2nd smallest now not in d31
    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;
    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest
    d12 = min(d12, d21); // 2nd smallest now not in d21
    d12 = min(d12, d22); // nor in d22
    d12 = min(d12, d31); // nor in d31
    d12 = min(d12, d32); // nor in d32
    d11.yz = min(d11.yz,d12.xy); // nor in d12.yz
    d11.y = min(d11.y,d12.z); // Only two more to go
    d11.y = min(d11.y,d11.z); // Done! (Phew!)
    return sqrt(d11.xy); // F1, F2
//*/// End of F1 and F2 block
}


void vertex() {
// Output:0

}

void fragment() {
// Input:2
	vec3 n_out2p0 = vec3(UV, 0.0);

// VectorDecompose:17
	float n_out17p0 = n_out2p0.x;
	float n_out17p1 = n_out2p0.y;
	float n_out17p2 = n_out2p0.z;

// Input:18
	float n_out18p0 = TIME;

// ScalarOp:19
	float n_in19p1 = 0.10000;
	float n_out19p0 = n_out18p0 * n_in19p1;

// VectorCompose:24
	vec3 n_out24p0 = vec3(n_out17p0, n_out17p1, n_out19p0);

// PerlinNoise3D:27
	vec3 n_in27p2 = vec3(20.00000, 20.00000, 20.00000);
	float n_out27p0;
	{
		n_out27p0 = perlin_noise_3d_np(n_out24p0 * n_in27p2);
	}

// RandomNoise:12
	float n_out12p0;
	{
		n_out12p0 = rand(vec4(n_out2p0, n_out18p0));
	}

// ScalarOp:13
	float n_out13p0 = n_out27p0 + n_out12p0;

// ScalarOp:14
	float n_in14p1 = 0.50000;
	float n_out14p0 = n_out13p0 * n_in14p1;

// VectorCompose:16
	vec3 n_out16p0 = vec3(n_out17p0, n_out17p1, n_out18p0);

// CelluarNoise3D:26
	vec3 n_in26p1 = vec3(10.00000, 10.00000, 1.00000);
	float n_in26p2 = 1.00000;
	vec3 n_out26p0;
	float n_out26p1;
	float n_out26p2;
	{
		
			n_out26p0 = vec3(cellular_noise_3d(n_out16p0 * n_in26p1, n_in26p2), 0.0);
			n_out26p1 = n_out26p0.x;
			n_out26p2 = n_out26p0.y;
			
	}

// ScalarOp:20
	float n_out20p0 = n_out26p1 - n_out26p2;

// ScalarFunc:21
	float n_out21p0 = abs(n_out20p0);

// ScalarOp:7
	float n_in7p1 = 0.05000;
	float n_out7p0 = step(n_out21p0, n_in7p1);

// ScalarMix:4
	float n_in4p1 = 1.00000;
	float n_out4p0 = mix(n_out14p0, n_in4p1, n_out7p0);

// Output:0
	COLOR.rgb = vec3(n_out4p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -774.74, -32 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 920, 160 )
nodes/fragment/2/node = SubResource( 107 )
nodes/fragment/2/position = Vector2( -760, -20 )
nodes/fragment/4/node = SubResource( 113 )
nodes/fragment/4/position = Vector2( 780, 160 )
nodes/fragment/6/node = SubResource( 114 )
nodes/fragment/6/position = Vector2( -500, 120 )
nodes/fragment/7/node = SubResource( 115 )
nodes/fragment/7/position = Vector2( 360, -20 )
nodes/fragment/12/node = SubResource( 99 )
nodes/fragment/12/position = Vector2( -40, 280 )
nodes/fragment/13/node = SubResource( 100 )
nodes/fragment/13/position = Vector2( 180, 220 )
nodes/fragment/14/node = SubResource( 101 )
nodes/fragment/14/position = Vector2( 360, 220 )
nodes/fragment/16/node = SubResource( 103 )
nodes/fragment/16/position = Vector2( -335, -23.5 )
nodes/fragment/17/node = SubResource( 104 )
nodes/fragment/17/position = Vector2( -560, -40 )
nodes/fragment/18/node = SubResource( 105 )
nodes/fragment/18/position = Vector2( -820, 120 )
nodes/fragment/19/node = SubResource( 106 )
nodes/fragment/19/position = Vector2( -652, 157.5 )
nodes/fragment/20/node = SubResource( 108 )
nodes/fragment/20/position = Vector2( 0, -260 )
nodes/fragment/21/node = SubResource( 109 )
nodes/fragment/21/position = Vector2( 160, -260 )
nodes/fragment/24/node = SubResource( 112 )
nodes/fragment/24/position = Vector2( -260, 120 )
nodes/fragment/26/node = SubResource( 164 )
nodes/fragment/26/position = Vector2( -80, -40 )
nodes/fragment/27/node = SubResource( 172 )
nodes/fragment/27/position = Vector2( -40, 140 )
nodes/fragment/connections = PoolIntArray( 7, 0, 4, 2, 4, 0, 0, 0, 12, 0, 13, 1, 2, 0, 12, 0, 13, 0, 14, 0, 14, 0, 4, 0, 17, 0, 16, 0, 17, 1, 16, 1, 2, 0, 17, 0, 18, 0, 19, 0, 20, 0, 21, 0, 17, 0, 24, 0, 17, 1, 24, 1, 19, 0, 24, 2, 21, 0, 7, 0, 18, 0, 12, 1, 26, 1, 20, 0, 26, 2, 20, 1, 16, 0, 26, 0, 18, 0, 16, 2, 24, 0, 27, 0, 27, 0, 13, 0 )

[sub_resource type="ShaderMaterial" id=117]
shader = SubResource( 116 )

[sub_resource type="VisualShaderNodeVectorInterp" id=118]

[sub_resource type="VisualShaderNodeScalarOp" id=119]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 9

[sub_resource type="VisualShaderNodeVectorDecompose" id=120]

[sub_resource type="VisualShaderNodeCustom" id=121]
default_input_values = [ 2, Vector3( 10, 10, 10 ), 3, 0.0 ]
script = ExtResource( 12 )

[sub_resource type="VisualShaderNodeInput" id=122]
input_name = "uv"

[sub_resource type="VisualShaderNodeInput" id=124]
input_name = "time"

[sub_resource type="VisualShaderNodeScalarOp" id=125]
default_input_values = [ 0, 0.0, 1, 1.0 ]

[sub_resource type="VisualShaderNodeScalarOp" id=126]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 2

[sub_resource type="VisualShaderNodeVectorOp" id=127]
default_input_values = [ 0, Vector3( 0, 0, 0 ), 1, Vector3( 1, 1, 1 ) ]

[sub_resource type="VisualShaderNodeVectorOp" id=128]
default_input_values = [ 0, Vector3( 0, 0, 0 ), 1, Vector3( 0.5, 0.5, 0.5 ) ]
operator = 2

[sub_resource type="VisualShader" id=129]
code = "shader_type canvas_item;


// SimplexNoise2DRG



// Modulo 289, optimizes to code without divisions
vec3 HELPER_SimplexNoise2DRG_HELPER_SimplexNoise2DRG_mod289_3(vec3 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float HELPER_SimplexNoise2DRG_mod289(float x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Permutation polynomial (ring size 289 = 17*17)
vec3 HELPER_SimplexNoise2DRG_permute_3(vec3 x) {
	return HELPER_SimplexNoise2DRG_HELPER_SimplexNoise2DRG_mod289_3(((x*34.0)+1.0)*x);
}

float HELPER_SimplexNoise2DRG_permute(float x) {
    return HELPER_SimplexNoise2DRG_mod289(((x * 34.0) + 1.0) * x);
}

// Hashed 2-D gradients with an extra rotation.
// (The constant 0.0243902439 is 1/41)
vec2 HELPER_SimplexNoise2DRG_rgrad2(vec2 p, float rot) {
/*// Map from a line to a diamond such that a shift maps to a rotation.
	float u = HELPER_SimplexNoise2DRG_permute(HELPER_SimplexNoise2DRG_permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift
	u = 4.0 * fract(u) - 2.0;
	// (This vector could be normalized, exactly or approximately.)
	return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0);
*/
// For more isotropic gradients, sin/cos can be used instead.
	float u = HELPER_SimplexNoise2DRG_permute(HELPER_SimplexNoise2DRG_permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift
	u = fract(u) * 6.28318530718; // 2*pi
	return vec2(cos(u), sin(u));
}

//*
//
// 2-D tiling simplex noise with rotating gradients and analytical derivative.
// The first component of the 3-element return vector is the noise value,
// and the second and third components are the x and y partial derivatives.
//
vec3 simplex_noise_2d_rg_p(vec2 pos, vec2 per, float rot) {
    // Hack: offset y slightly to hide some rare artifacts
    pos.y += 0.01;
    // Skew to hexagonal grid
    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);
    
    vec2 i0 = floor(uv);
    vec2 f0 = fract(uv);
    // Traversal order
    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    
    // Unskewed grid points in (x,y) space
    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);
    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);
    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);
    
    // Integer grid point indices in (u,v) space
    i1 = i0 + i1;
    vec2 i2 = i0 + vec2(1.0, 1.0);
    
    // Vectors in unskewed (x,y) coordinates from
    // each of the simplex corners to the evaluation point
    vec2 d0 = pos - p0;
    vec2 d1 = pos - p1;
    vec2 d2 = pos - p2;
    
    // Wrap i0, i1 and i2 to the desired period before gradient hashing:
    // wrap points in (x,y), map to (u,v)
    vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);
    vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);
    vec3 iuw = xw + 0.5 * yw;
    vec3 ivw = yw;
    
    // Create gradients from indices
    vec2 g0 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.x, ivw.x), rot);
    vec2 g1 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.y, ivw.y), rot);
    vec2 g2 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.z, ivw.z), rot);
    
    // Gradients dot vectors to corresponding corners
    // (The derivatives of this are simply the gradients)
    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));
    
    // Radial weights from corners
    // 0.8 is the square of 2/sqrt(5), the distance from
    // a grid point to the nearest simplex boundary
    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));
    
    // Partial derivatives for analytical gradient computation
    vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);
    vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);
    
    // Set influence of each surflet to zero outside radius sqrt(0.8)
    if (t.x < 0.0) {
        dtdx.x = 0.0;
        dtdy.x = 0.0;
        t.x = 0.0;
    }
    if (t.y < 0.0) {
        dtdx.y = 0.0;
        dtdy.y = 0.0;
        t.y = 0.0;
    }
    if (t.z < 0.0) {
        dtdx.z = 0.0;
        dtdy.z = 0.0;
        t.z = 0.0;
    }
    
    // Fourth power of t (and third power for derivative)
    vec3 t2 = t * t;
    vec3 t4 = t2 * t2;
    vec3 t3 = t2 * t;
    
    // Final noise value is:
    // sum of ((radial weights) times (gradient dot vector from corner))
    float n = dot(t4, w);
    
    // Final analytical derivative (gradient of a sum of scalar products)
    vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;
    vec2 dn0 = t4.x * g0 + dt0 * w.x;
    vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;
    vec2 dn1 = t4.y * g1 + dt1 * w.y;
    vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;
    vec2 dn2 = t4.z * g2 + dt2 * w.z;
    
    return 11.0*vec3(n, dn0 + dn1 + dn2);
}

/*/
//
// 2-D tiling simplex noise with rotating gradients,
// but without the analytical derivative.
//
float simplex_noise_2d_rg_p(vec2 pos, vec2 per, float rot) {
    // Offset y slightly to hide some rare artifacts
    pos.y += 0.001;
    // Skew to hexagonal grid
    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);
    
    vec2 i0 = floor(uv);
    vec2 f0 = fract(uv);
    // Traversal order
    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    
    // Unskewed grid points in (x,y) space
    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);
    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);
    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);
    
    // Integer grid point indices in (u,v) space
    i1 = i0 + i1;
    vec2 i2 = i0 + vec2(1.0, 1.0);
    
    // Vectors in unskewed (x,y) coordinates from
    // each of the simplex corners to the evaluation point
    vec2 d0 = pos - p0;
    vec2 d1 = pos - p1;
    vec2 d2 = pos - p2;
    
    // Wrap i0, i1 and i2 to the desired period before gradient hashing:
    // wrap points in (x,y), map to (u,v)
    vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);
    vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);
    vec3 iuw = xw + 0.5 * yw;
    vec3 ivw = yw;
    
    // Create gradients from indices
    vec2 g0 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.x, ivw.x), rot);
    vec2 g1 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.y, ivw.y), rot);
    vec2 g2 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.z, ivw.z), rot);
    
    // Gradients dot vectors to corresponding corners
    // (The derivatives of this are simply the gradients)
    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));
    
    // Radial weights from corners
    // 0.8 is the square of 2/sqrt(5), the distance from
    // a grid point to the nearest simplex boundary
    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));
    
    // Set influence of each surflet to zero outside radius sqrt(0.8)
    t = max(t, vec3(0.0));
    
    // Fourth power of t
    vec3 t2 = t * t;
    vec3 t4 = t2 * t2;
    
    // Final noise value is:
    // sum of ((radial weights) times (gradient dot vector from corner))
    float n = dot(t4, w);
    
    // Rescale to cover the range [-1,1] reasonably well
    return 11.0*n;
}

//*/

//*
//
// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.
// The first component of the 3-element return vector is the noise value,
// and the second and third components are the x and y partial derivatives.
//
vec3 simplex_noise_2d_rg_np(vec2 pos, float rot) {
    // Offset y slightly to hide some rare artifacts
    pos.y += 0.001;
    // Skew to hexagonal grid
    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);
    
    vec2 i0 = floor(uv);
    vec2 f0 = fract(uv);
    // Traversal order
    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    
    // Unskewed grid points in (x,y) space
    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);
    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);
    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);
    
    // Integer grid point indices in (u,v) space
    i1 = i0 + i1;
    vec2 i2 = i0 + vec2(1.0, 1.0);
    
    // Vectors in unskewed (x,y) coordinates from
    // each of the simplex corners to the evaluation point
    vec2 d0 = pos - p0;
    vec2 d1 = pos - p1;
    vec2 d2 = pos - p2;
    
    vec3 x = vec3(p0.x, p1.x, p2.x);
    vec3 y = vec3(p0.y, p1.y, p2.y);
    vec3 iuw = x + 0.5 * y;
    vec3 ivw = y;
    
    // Avoid precision issues in permutation
    iuw = HELPER_SimplexNoise2DRG_HELPER_SimplexNoise2DRG_mod289_3(iuw);
    ivw = HELPER_SimplexNoise2DRG_HELPER_SimplexNoise2DRG_mod289_3(ivw);
    
    // Create gradients from indices
    vec2 g0 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.x, ivw.x), rot);
    vec2 g1 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.y, ivw.y), rot);
    vec2 g2 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.z, ivw.z), rot);
    
    // Gradients dot vectors to corresponding corners
    // (The derivatives of this are simply the gradients)
    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));
    
    // Radial weights from corners
    // 0.8 is the square of 2/sqrt(5), the distance from
    // a grid point to the nearest simplex boundary
    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));
    
    // Partial derivatives for analytical gradient computation
    vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);
    vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);
    
    // Set influence of each surflet to zero outside radius sqrt(0.8)
    if (t.x < 0.0) {
        dtdx.x = 0.0;
        dtdy.x = 0.0;
        t.x = 0.0;
    }
    if (t.y < 0.0) {
        dtdx.y = 0.0;
        dtdy.y = 0.0;
        t.y = 0.0;
    }
    if (t.z < 0.0) {
        dtdx.z = 0.0;
        dtdy.z = 0.0;
        t.z = 0.0;
    }
    
    // Fourth power of t (and third power for derivative)
    vec3 t2 = t * t;
    vec3 t4 = t2 * t2;
    vec3 t3 = t2 * t;
    
    // Final noise value is:
    // sum of ((radial weights) times (gradient dot vector from corner))
    float n = dot(t4, w);
    
    // Final analytical derivative (gradient of a sum of scalar products)
    vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;
    vec2 dn0 = t4.x * g0 + dt0 * w.x;
    vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;
    vec2 dn1 = t4.y * g1 + dt1 * w.y;
    vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;
    vec2 dn2 = t4.z * g2 + dt2 * w.z;
    
    return 11.0*vec3(n, dn0 + dn1 + dn2);
}

/*/

//
// 2-D non-tiling simplex noise with rotating gradients,
// without the analytical derivative.
//
float simplex_noise_2d_rg_np(vec2 pos, float rot) {
    // Offset y slightly to hide some rare artifacts
    pos.y += 0.001;
    // Skew to hexagonal grid
    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);
    
    vec2 i0 = floor(uv);
    vec2 f0 = fract(uv);
    // Traversal order
    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    
    // Unskewed grid points in (x,y) space
    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);
    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);
    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);
    
    // Integer grid point indices in (u,v) space
    i1 = i0 + i1;
    vec2 i2 = i0 + vec2(1.0, 1.0);
    
    // Vectors in unskewed (x,y) coordinates from
    // each of the simplex corners to the evaluation point
    vec2 d0 = pos - p0;
    vec2 d1 = pos - p1;
    vec2 d2 = pos - p2;
    
    // Wrap i0, i1 and i2 to the desired period before gradient hashing:
    // wrap points in (x,y), map to (u,v)
    vec3 x = vec3(p0.x, p1.x, p2.x);
    vec3 y = vec3(p0.y, p1.y, p2.y);
    vec3 iuw = x + 0.5 * y;
    vec3 ivw = y;
    
    // Avoid precision issues in permutation
    iuw = HELPER_SimplexNoise2DRG_HELPER_SimplexNoise2DRG_mod289_3(iuw);
    ivw = HELPER_SimplexNoise2DRG_HELPER_SimplexNoise2DRG_mod289_3(ivw);
    
    // Create gradients from indices
    vec2 g0 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.x, ivw.x), rot);
    vec2 g1 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.y, ivw.y), rot);
    vec2 g2 = HELPER_SimplexNoise2DRG_rgrad2(vec2(iuw.z, ivw.z), rot);
    
    // Gradients dot vectors to corresponding corners
    // (The derivatives of this are simply the gradients)
    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));
    
    // Radial weights from corners
    // 0.8 is the square of 2/sqrt(5), the distance from
    // a grid point to the nearest simplex boundary
    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));
    
    // Set influence of each surflet to zero outside radius sqrt(0.8)
    t = max(t, vec3(0.0));
    
    // Fourth power of t
    vec3 t2 = t * t;
    vec3 t4 = t2 * t2;
    
    // Final noise value is:
    // sum of ((radial weights) times (gradient dot vector from corner))
    float n = dot(t4, w);
    
    // Rescale to cover the range [-1,1] reasonably well
    return 11.0*n;
}

//*/


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// Input:5
	float n_out5p0 = TIME;

// SimplexNoise2DRG:2
	vec3 n_in2p2 = vec3(10.00000, 10.00000, 10.00000);
	float n_out2p0;
	vec3 n_out2p1;
	{
		
			 vec3 result = simplex_noise_2d_rg_np(((n_out3p0).xy).xy * (n_in2p2).xy.xy, n_out5p0);
			n_out2p0 = result.x;
			n_out2p1 = vec3(result.xy, 0.0);
			
	}

// VectorOp:8
	vec3 n_in8p1 = vec3(1.00000, 1.00000, 1.00000);
	vec3 n_out8p0 = n_out2p1 + n_in8p1;

// VectorOp:9
	vec3 n_in9p1 = vec3(0.50000, 0.50000, 0.50000);
	vec3 n_out9p0 = n_out8p0 * n_in9p1;

// ScalarOp:6
	float n_in6p1 = 1.00000;
	float n_out6p0 = n_out2p0 + n_in6p1;

// ScalarOp:7
	float n_in7p1 = 0.50000;
	float n_out7p0 = n_out6p0 * n_in7p1;

// VectorDecompose:12
	float n_out12p0 = n_out3p0.x;
	float n_out12p1 = n_out3p0.y;
	float n_out12p2 = n_out3p0.z;

// ScalarOp:11
	float n_in11p1 = 0.50000;
	float n_out11p0 = step(n_out12p0, n_in11p1);

// VectorMix:10
	vec3 n_out10p0 = mix(n_out9p0, vec3(n_out7p0), vec3(n_out11p0));

// Output:0
	COLOR.rgb = n_out10p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -471.24, -134.5 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 780, 100 )
nodes/fragment/2/node = SubResource( 121 )
nodes/fragment/2/position = Vector2( -40, 160 )
nodes/fragment/3/node = SubResource( 122 )
nodes/fragment/3/position = Vector2( -280, 100 )
nodes/fragment/5/node = SubResource( 124 )
nodes/fragment/5/position = Vector2( -260, 220 )
nodes/fragment/6/node = SubResource( 125 )
nodes/fragment/6/position = Vector2( 237, 42.5 )
nodes/fragment/7/node = SubResource( 126 )
nodes/fragment/7/position = Vector2( 400, 40 )
nodes/fragment/8/node = SubResource( 127 )
nodes/fragment/8/position = Vector2( 240, 160 )
nodes/fragment/9/node = SubResource( 128 )
nodes/fragment/9/position = Vector2( 400, 160 )
nodes/fragment/10/node = SubResource( 118 )
nodes/fragment/10/position = Vector2( 620, 100 )
nodes/fragment/11/node = SubResource( 119 )
nodes/fragment/11/position = Vector2( 400, -100 )
nodes/fragment/12/node = SubResource( 120 )
nodes/fragment/12/position = Vector2( -40, -100 )
nodes/fragment/connections = PoolIntArray( 3, 0, 2, 0, 2, 0, 6, 0, 6, 0, 7, 0, 2, 1, 8, 0, 8, 0, 9, 0, 7, 0, 10, 1, 9, 0, 10, 0, 10, 0, 0, 0, 11, 0, 10, 2, 12, 0, 11, 0, 3, 0, 12, 0, 5, 0, 2, 3 )

[sub_resource type="ShaderMaterial" id=130]
shader = SubResource( 129 )

[sub_resource type="VisualShaderNodeVectorOp" id=131]
default_input_values = [ 0, Vector3( 0, 0, 0 ), 1, Vector3( 1, 1, 1 ) ]

[sub_resource type="VisualShaderNodeVectorOp" id=132]
default_input_values = [ 0, Vector3( 0, 0, 0 ), 1, Vector3( 0.5, 0.5, 0.5 ) ]
operator = 2

[sub_resource type="VisualShaderNodeVectorScalarMix" id=133]

[sub_resource type="VisualShaderNodeScalarOp" id=134]
default_input_values = [ 0, 0.5, 1, 0.5 ]
operator = 9

[sub_resource type="VisualShaderNodeInput" id=135]
input_name = "uv"

[sub_resource type="VisualShaderNodeCustom" id=136]
default_input_values = [ 1, Vector3( 10, 10, 10 ) ]
script = ExtResource( 13 )

[sub_resource type="VisualShaderNodeVectorDecompose" id=138]

[sub_resource type="VisualShaderNodeVectorCompose" id=139]

[sub_resource type="VisualShaderNodeInput" id=140]
input_name = "time"

[sub_resource type="VisualShaderNodeScalarOp" id=141]
default_input_values = [ 0, 0.0, 1, 0.1 ]
operator = 2

[sub_resource type="VisualShader" id=142]
code = "shader_type canvas_item;


// SimplexNoise3D


// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
// 

vec3 HELPER_SimplexNoise3D_mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_SimplexNoise3D_mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_SimplexNoise3D_permute(vec4 x) {
    return HELPER_SimplexNoise3D_mod289_4(((x*34.0)+1.0)*x);
}

vec4 HELPER_SimplexNoise3D_taylorInvSqrt(vec4 r) {
    return 2.79284291400159 - 0.85373472095314 * r;
}

float simplex_noise_3d(vec3 v, out vec3 gradient) {
    vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    
    // First corner
    vec3 i  = floor(v + dot(v, vec3(C.y)) );
    vec3 x0 =   v - i + dot(i, vec3(C.x)) ;
    
    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );
    
    //   x0 = x0 - 0.0 + 0.0 * C.xxx;
    //   x1 = x0 - i1  + 1.0 * C.xxx;
    //   x2 = x0 - i2  + 2.0 * C.xxx;
    //   x3 = x0 - 1.0 + 3.0 * C.xxx;
    vec3 x1 = x0 - i1 + vec3(C.x);
    vec3 x2 = x0 - i2 + vec3(C.y); // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
    
    // Permutations
    i = HELPER_SimplexNoise3D_mod289_3(i); 
    vec4 p = HELPER_SimplexNoise3D_permute( HELPER_SimplexNoise3D_permute( HELPER_SimplexNoise3D_permute( 
    		 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
    	   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
    	   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
    
    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;
    
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
    
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
    
    vec4 x = x_ *ns.x + vec4(ns.y);
    vec4 y = y_ *ns.x + vec4(ns.y);
    vec4 h = 1.0 - abs(x) - abs(y);
    
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );
    
    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    
    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;
    
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
    
    //Normalise gradients
    vec4 norm = HELPER_SimplexNoise3D_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    
    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), vec4(0.0));
    vec4 m2 = m * m;
    vec4 m4 = m2 * m2;
    vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));
    
    // Determine noise gradient
    vec4 temp = m2 * m * pdotx;
    gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);
    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;
    gradient *= 42.0;
    
    return 22.0 * dot(m4, pdotx);
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// VectorDecompose:6
	float n_out6p0 = n_out3p0.x;
	float n_out6p1 = n_out3p0.y;
	float n_out6p2 = n_out3p0.z;

// Input:8
	float n_out8p0 = TIME;

// ScalarOp:9
	float n_in9p1 = 0.10000;
	float n_out9p0 = n_out8p0 * n_in9p1;

// VectorCompose:7
	vec3 n_out7p0 = vec3(n_out6p0, n_out6p1, n_out9p0);

// SimplexNoise3D:4
	vec3 n_in4p1 = vec3(10.00000, 10.00000, 10.00000);
	float n_out4p0;
	vec3 n_out4p1;
	{
		
				n_out4p0 = simplex_noise_3d(n_out7p0 * n_in4p1, n_out4p1);
			
	}

// ScalarOp:13
	float n_in13p0 = 0.50000;
	float n_out13p0 = step(n_in13p0, n_out6p0);

// VectorScalarMix:12
	vec3 n_out12p0 = mix(vec3(n_out4p0), n_out4p1, n_out13p0);

// VectorOp:10
	vec3 n_in10p1 = vec3(1.00000, 1.00000, 1.00000);
	vec3 n_out10p0 = n_out12p0 + n_in10p1;

// VectorOp:11
	vec3 n_in11p1 = vec3(0.50000, 0.50000, 0.50000);
	vec3 n_out11p0 = n_out10p0 * n_in11p1;

// Output:0
	COLOR.rgb = n_out11p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -853.74, 19 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 900, 100 )
nodes/fragment/3/node = SubResource( 135 )
nodes/fragment/3/position = Vector2( -640, 120 )
nodes/fragment/4/node = SubResource( 136 )
nodes/fragment/4/position = Vector2( -40, 140 )
nodes/fragment/6/node = SubResource( 138 )
nodes/fragment/6/position = Vector2( -480, 80 )
nodes/fragment/7/node = SubResource( 139 )
nodes/fragment/7/position = Vector2( -260, 80 )
nodes/fragment/8/node = SubResource( 140 )
nodes/fragment/8/position = Vector2( -660, 200 )
nodes/fragment/9/node = SubResource( 141 )
nodes/fragment/9/position = Vector2( -480, 200 )
nodes/fragment/10/node = SubResource( 131 )
nodes/fragment/10/position = Vector2( 460, 100 )
nodes/fragment/11/node = SubResource( 132 )
nodes/fragment/11/position = Vector2( 660, 100 )
nodes/fragment/12/node = SubResource( 133 )
nodes/fragment/12/position = Vector2( 260, 140 )
nodes/fragment/13/node = SubResource( 134 )
nodes/fragment/13/position = Vector2( 20, -40 )
nodes/fragment/connections = PoolIntArray( 3, 0, 6, 0, 6, 0, 7, 0, 6, 1, 7, 1, 7, 0, 4, 0, 8, 0, 9, 0, 9, 0, 7, 2, 10, 0, 11, 0, 11, 0, 0, 0, 4, 0, 12, 0, 4, 1, 12, 1, 12, 0, 10, 0, 13, 0, 12, 2, 6, 0, 13, 1 )

[sub_resource type="ShaderMaterial" id=143]
shader = SubResource( 142 )

[sub_resource type="VisualShaderNodeCustom" id=145]
default_input_values = [ 2, Vector3( 10, 10, 10 ), 3, 10.0 ]
script = ExtResource( 14 )

[sub_resource type="VisualShaderNodeScalarOp" id=146]
default_input_values = [ 0, 0.0, 1, 1.0 ]

[sub_resource type="VisualShaderNodeScalarOp" id=147]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 2

[sub_resource type="VisualShaderNodeInput" id=148]
input_name = "uv"

[sub_resource type="VisualShaderNodeInput" id=149]
input_name = "screen_uv"

[sub_resource type="VisualShaderNodeVectorDecompose" id=150]

[sub_resource type="VisualShaderNodeVectorDecompose" id=151]

[sub_resource type="VisualShaderNodeVectorCompose" id=152]

[sub_resource type="VisualShader" id=153]
code = "shader_type canvas_item;


// SimplexNoise4D


// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
// 

vec4 HELPER_SimplexNoise4D_mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float HELPER_SimplexNoise4D_mod289(float x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_SimplexNoise4D_permute_4(vec4 x) {
    return HELPER_SimplexNoise4D_mod289_4(((x * 34.0) + 1.0) * x);
}

float HELPER_SimplexNoise4D_permute(float x) {
    return HELPER_SimplexNoise4D_mod289(((x * 34.0) + 1.0) * x);
}

vec4 HELPER_SimplexNoise4D_taylorInvSqrt_4(vec4 r) {
    return 2.79284291400159 - 1.85373472095314 * r;
}

float HELPER_SimplexNoise4D_taylorInvSqrt(float r) {
    return 2.79284291400159 - 1.85373472095314 * r;
}

vec4 HELPER_SimplexNoise4D_grad4(float j, vec4 ip) {
    vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
    vec4 p, s;

    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
    s = vec4(lessThan(p, vec4(0.0)));
    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

    return p;
}

float simplex_noise_4d(vec4 v) {
    vec4 C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4
                    0.276393202250021,  // 2 * G4
                    0.414589803375032,  // 3 * G4
                   -0.447213595499958); // -1 + 4 * G4
    
    // First corner
    vec4 i  = floor(v + dot(v, vec4(0.309016994374947451)) ); //// (sqrt(5) - 1)/4
    vec4 x0 = v -   i + dot(i, C.xxxx);
    
    // Other corners
    
    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
    vec4 i0;
    vec3 isX = step( x0.yzw, x0.xxx );
    vec3 isYZ = step( x0.zww, x0.yyz );
    //  i0.x = dot( isX, vec3( 1.0 ) );
    i0.x = isX.x + isX.y + isX.z;
    i0.yzw = 1.0 - isX;
    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
    i0.y += isYZ.x + isYZ.y;
    i0.zw += 1.0 - isYZ.xy;
    i0.z += isYZ.z;
    i0.w += 1.0 - isYZ.z;
    
    // i0 now contains the unique values 0,1,2,3 in each channel
    vec4 i3 = clamp( i0, 0.0, 1.0 );
    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );
    
    //  x0 = x0 - 0.0 + 0.0 * C.xxxx
    //  x1 = x0 - i1  + 1.0 * C.xxxx
    //  x2 = x0 - i2  + 2.0 * C.xxxx
    //  x3 = x0 - i3  + 3.0 * C.xxxx
    //  x4 = x0 - 1.0 + 4.0 * C.xxxx
    vec4 x1 = x0 - i1 + C.xxxx;
    vec4 x2 = x0 - i2 + C.yyyy;
    vec4 x3 = x0 - i3 + C.zzzz;
    vec4 x4 = x0 + C.wwww;
    
    // Permutations
    i = HELPER_SimplexNoise4D_mod289_4(i);
    float j0 = HELPER_SimplexNoise4D_permute( HELPER_SimplexNoise4D_permute( HELPER_SimplexNoise4D_permute( HELPER_SimplexNoise4D_permute(i.w) + i.z) + i.y) + i.x);
    vec4 j1 = HELPER_SimplexNoise4D_permute_4( HELPER_SimplexNoise4D_permute_4( HELPER_SimplexNoise4D_permute_4( HELPER_SimplexNoise4D_permute_4 (
                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
    
    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.
    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;
    
    vec4 p0 = HELPER_SimplexNoise4D_grad4(j0,   ip);
    vec4 p1 = HELPER_SimplexNoise4D_grad4(j1.x, ip);
    vec4 p2 = HELPER_SimplexNoise4D_grad4(j1.y, ip);
    vec4 p3 = HELPER_SimplexNoise4D_grad4(j1.z, ip);
    vec4 p4 = HELPER_SimplexNoise4D_grad4(j1.w, ip);
    
    // Normalise gradients
    vec4 norm = HELPER_SimplexNoise4D_taylorInvSqrt_4(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    p4 *= HELPER_SimplexNoise4D_taylorInvSqrt(dot(p4,p4));
    
    // Mix contributions from the five corners
    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), vec3(0.0));
    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)), vec2(0.0));
    m0 = m0 * m0;
    m1 = m1 * m1;
    return 33.0 * (dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:5
	vec3 n_out5p0 = vec3(UV, 0.0);

// VectorDecompose:7
	float n_out7p0 = n_out5p0.x;
	float n_out7p1 = n_out5p0.y;
	float n_out7p2 = n_out5p0.z;

// Input:6
	vec3 n_out6p0 = vec3(SCREEN_UV, 0.0);

// VectorDecompose:8
	float n_out8p0 = n_out6p0.x;
	float n_out8p1 = n_out6p0.y;
	float n_out8p2 = n_out6p0.z;

// VectorCompose:9
	vec3 n_out9p0 = vec3(n_out7p0, n_out7p1, n_out8p0);

// SimplexNoise4D:2
	vec3 n_in2p2 = vec3(10.00000, 10.00000, 10.00000);
	float n_in2p3 = 10.00000;
	float n_out2p0;
	{
		n_out2p0 = simplex_noise_4d(vec4(n_out9p0, n_out8p1) * vec4(n_in2p2, n_in2p3));
	}

// ScalarOp:3
	float n_in3p1 = 1.00000;
	float n_out3p0 = n_out2p0 + n_in3p1;

// ScalarOp:4
	float n_in4p1 = 0.50000;
	float n_out4p0 = n_out3p0 * n_in4p1;

// Output:0
	COLOR.rgb = vec3(n_out4p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -853.74, 19 )
mode = 1
flags/light_only = false
nodes/fragment/2/node = SubResource( 145 )
nodes/fragment/2/position = Vector2( -180, 140 )
nodes/fragment/3/node = SubResource( 146 )
nodes/fragment/3/position = Vector2( 40, 140 )
nodes/fragment/4/node = SubResource( 147 )
nodes/fragment/4/position = Vector2( 220, 140 )
nodes/fragment/5/node = SubResource( 148 )
nodes/fragment/5/position = Vector2( -900, 80 )
nodes/fragment/6/node = SubResource( 149 )
nodes/fragment/6/position = Vector2( -940, 200 )
nodes/fragment/7/node = SubResource( 150 )
nodes/fragment/7/position = Vector2( -700, 40 )
nodes/fragment/8/node = SubResource( 151 )
nodes/fragment/8/position = Vector2( -700, 180 )
nodes/fragment/9/node = SubResource( 152 )
nodes/fragment/9/position = Vector2( -420, 40 )
nodes/fragment/connections = PoolIntArray( 2, 0, 3, 0, 3, 0, 4, 0, 4, 0, 0, 0, 9, 0, 2, 0, 7, 0, 9, 0, 7, 1, 9, 1, 8, 0, 9, 2, 8, 1, 2, 1, 5, 0, 7, 0, 6, 0, 8, 0 )

[sub_resource type="ShaderMaterial" id=154]
shader = SubResource( 153 )

[node name="Node2D" type="Node2D"]

[node name="Rotation" type="Sprite" parent="."]
material = SubResource( 7 )
position = Vector2( 57.2789, 57.2789 )
texture = ExtResource( 1 )

[node name="Label" type="Label" parent="Rotation"]
margin_left = -25.9443
margin_top = 38.4532
margin_right = 27.0557
margin_bottom = 52.4532
text = "Rotation"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Rotation 3D" type="Sprite" parent="."]
material = SubResource( 12 )
position = Vector2( 162.129, 55.3282 )
texture = ExtResource( 1 )

[node name="Label" type="Label" parent="Rotation 3D"]
margin_left = -25.9443
margin_top = 38.4532
margin_right = 27.0557
margin_bottom = 52.4532
text = "Rotation 3D"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 2D" type="ColorRect" parent="."]
material = SubResource( 17 )
margin_left = 284.839
margin_top = 34.1266
margin_right = 345.839
margin_bottom = 95.1266
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 2D"]
margin_left = -13.8511
margin_top = 63.2814
margin_right = 92.1489
margin_bottom = 77.2814
text = "Perlin noise (2D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 2D periodic" type="ColorRect" parent="."]
material = SubResource( 23 )
margin_left = 286.961
margin_top = 143.728
margin_right = 347.961
margin_bottom = 204.728
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 2D periodic"]
margin_left = -10.4644
margin_top = 65.1213
margin_right = 77.5356
margin_bottom = 96.1213
text = " Perlin noise
(2D, periodic)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 3D" type="ColorRect" parent="."]
material = SubResource( 34 )
margin_left = 416.5
margin_top = 31.5
margin_right = 477.5
margin_bottom = 92.5
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 3D"]
margin_left = -14.3511
margin_top = 63.2814
margin_right = 91.6489
margin_bottom = 77.2814
text = "Perlin noise (3D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 3D periodic" type="ColorRect" parent="."]
material = SubResource( 43 )
margin_left = 422.157
margin_top = 143.223
margin_right = 483.157
margin_bottom = 204.223
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 3D periodic"]
margin_left = -14.3511
margin_top = 63.2814
margin_right = 91.6489
margin_bottom = 77.2814
text = " Perlin noise
(3D, periodic)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 4D" type="ColorRect" parent="."]
material = SubResource( 52 )
margin_left = 545.865
margin_top = 32.3969
margin_right = 606.865
margin_bottom = 93.3969
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 4D"]
margin_left = -20.2103
margin_top = 62.7814
margin_right = 85.7897
margin_bottom = 76.7814
text = "Perlin noise (4D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 4D periodic" type="ColorRect" parent="."]
material = SubResource( 62 )
margin_left = 550.108
margin_top = 144.12
margin_right = 611.108
margin_bottom = 205.12
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 4D periodic"]
margin_left = -10.1005
margin_top = 63.7071
margin_right = 77.8995
margin_bottom = 94.7071
text = " Perlin noise
(4D, periodic)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Random noise" type="ColorRect" parent="."]
material = SubResource( 70 )
margin_left = 676.918
margin_top = 28.6563
margin_right = 737.918
margin_bottom = 89.6563
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Random noise"]
margin_left = 4.68323
margin_top = 66.0023
margin_right = 59.6832
margin_bottom = 97.0023
text = "Random
  noise"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Cellular Noise 2D" type="ColorRect" parent="."]
material = SubResource( 79 )
margin_left = 801.277
margin_top = 28.8443
margin_right = 862.277
margin_bottom = 89.8443
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Cellular Noise 2D"]
margin_left = -9.0
margin_top = 66.0
margin_right = 74.0
margin_bottom = 97.0
text = "Cellular noise
       (2D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Cellular Noise 2D 2x2" type="ColorRect" parent="."]
material = SubResource( 88 )
margin_left = 911.52
margin_top = 30.0354
margin_right = 972.52
margin_bottom = 91.0354
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Cellular Noise 2D 2x2"]
margin_left = -9.0
margin_top = 66.0
margin_right = 74.0
margin_bottom = 97.0
text = "Cellular noise
    (2D, 2x2)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Cellular Noise 3D" type="ColorRect" parent="."]
material = SubResource( 94 )
margin_left = 800.958
margin_top = 139.476
margin_right = 861.958
margin_bottom = 200.476
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Cellular Noise 3D"]
margin_left = -9.0
margin_top = 66.0
margin_right = 74.0
margin_bottom = 97.0
text = "Cellular noise
       (3D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Cellular Noise 3D 2x2x2" type="ColorRect" parent="."]
material = SubResource( 97 )
margin_left = 912.797
margin_top = 141.998
margin_right = 973.797
margin_bottom = 202.998
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Cellular Noise 3D 2x2x2"]
margin_left = -9.0
margin_top = 66.0
margin_right = 78.0
margin_bottom = 97.0
text = "Cellular noise
  (3D, 2x2x2)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Combined noises" type="ColorRect" parent="."]
material = SubResource( 117 )
margin_left = 678.797
margin_top = 139.998
margin_right = 739.797
margin_bottom = 200.998
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Combined noises"]
margin_left = -0.0203247
margin_top = 65.4388
margin_right = 64.9797
margin_bottom = 96.4388
text = "Combined
   noises"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Simplex noise 2D" type="ColorRect" parent="."]
material = SubResource( 130 )
margin_left = 290.272
margin_top = 263.252
margin_right = 351.272
margin_bottom = 324.252
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Simplex noise 2D"]
margin_left = -12.8375
margin_top = 65.4054
margin_right = 77.1625
margin_bottom = 113.405
text = "Simplex noise
 (2D, rotating
    gradient)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Simplex noise 3D" type="ColorRect" parent="."]
material = SubResource( 143 )
margin_left = 419.847
margin_top = 263.334
margin_right = 480.847
margin_bottom = 324.334
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Simplex noise 3D"]
margin_left = -12.8375
margin_top = 65.4054
margin_right = 77.1625
margin_bottom = 113.405
text = "Simplex noise
        (3D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Simplex noise 4D" type="ColorRect" parent="."]
material = SubResource( 154 )
margin_left = 551.736
margin_top = 264.456
margin_right = 612.736
margin_bottom = 325.456
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Simplex noise 4D"]
margin_left = -12.8375
margin_top = 65.4054
margin_right = 77.1625
margin_bottom = 113.405
text = "Simplex noise
        (4D)"
__meta__ = {
"_edit_use_anchors_": false
}
