[gd_scene load_steps=170 format=2]

[ext_resource path="res://addons/visual_shader_node_library/examples/3D/default_env.tres" type="Environment" id=1]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/emission_add.gd" type="Script" id=2]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/emission_multiply.gd" type="Script" id=3]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/refraction.gd" type="Script" id=4]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/textures/rock_metal.jpg" type="Texture" id=5]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/textures/texture_rock_depth.png" type="Texture" id=6]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/textures/texture_rock_ao.png" type="Texture" id=7]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/distance_fade.gd" type="Script" id=8]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/dither.gd" type="Script" id=9]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/depth_world_position.gd" type="Script" id=10]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/rotation_2d.gd" type="Script" id=11]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/deep_parallax.gd" type="Script" id=12]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/textures/texture_rock_albedo.png" type="Texture" id=13]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/textures/texture_rock_metal.png" type="Texture" id=14]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/proximity_fade.gd" type="Script" id=15]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/textures/texture_rock_normal.png" type="Texture" id=16]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/models/test_bed/test_bed.tscn" type="PackedScene" id=17]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/tester.gd" type="Script" id=18]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/depth.gd" type="Script" id=19]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/rotation_3d.gd" type="Script" id=20]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/flowmap_add_uv.gd" type="Script" id=21]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/flowmap.gd" type="Script" id=22]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/object_world_position.gd" type="Script" id=23]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/textures/flowmap.png" type="Texture" id=24]
[ext_resource path="res://addons/visual_shader_node_library/examples/3D/models/terrain.tscn" type="PackedScene" id=25]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/screenspace_refraction.gd" type="Script" id=26]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/read_normalmap.gd" type="Script" id=27]

[sub_resource type="SphereMesh" id=47]
radius = 1.5
height = 3.0

[sub_resource type="VisualShaderNodeTexture" id=48]
texture = ExtResource( 16 )
texture_type = 2

[sub_resource type="VisualShaderNodeScalarConstant" id=49]
constant = 1.0

[sub_resource type="VisualShaderNodeScalarConstant" id=50]
constant = 0.47

[sub_resource type="VisualShaderNodeTexture" id=51]
texture = ExtResource( 7 )

[sub_resource type="VisualShaderNodeTexture" id=52]
texture = ExtResource( 14 )

[sub_resource type="VisualShaderNodeScalarOp" id=53]
default_input_values = [ 0, 0.0, 1, 0.86 ]
operator = 2

[sub_resource type="VisualShaderNodeVectorDecompose" id=54]

[sub_resource type="VisualShaderNodeScalarConstant" id=55]
constant = 0.5

[sub_resource type="VisualShaderNodeGlobalExpression" id=56]
size = Vector2( 569, 136 )
expression = "/*The parallax texture must be passed as sampler2D from a
TextureUniform node. The texture can be set in the 
Shader params in the inspector panel */"

[sub_resource type="VisualShaderNodeGlobalExpression" id=57]
size = Vector2( 304, 143 )
expression = "// Simply use the output 
// as uv for other textures"

[sub_resource type="VisualShaderNodeTexture" id=58]
texture = ExtResource( 13 )
texture_type = 1

[sub_resource type="VisualShaderNodeCustom" id=59]
default_input_values = [ 2, 0.05, 3, 8, 4, 32, 9, Vector2( 1, 1 ) ]
script = ExtResource( 19 )

[sub_resource type="VisualShaderNodeCustom" id=60]
default_input_values = [ 2, 0.05, 3, 8, 4, 32, 9, Vector2( 1, 1 ), 10, "test" ]
script = ExtResource( 12 )

[sub_resource type="VisualShaderNodeTextureUniform" id=61]
uniform_name = "ParallaxTexture"

[sub_resource type="VisualShaderNodeScalarConstant" id=62]
constant = 0.18

[sub_resource type="VisualShader" id=63]
code = "shader_type spatial;
uniform sampler2D ParallaxTexture;
uniform sampler2D tex_frg_2 : hint_albedo;
uniform sampler2D tex_frg_14;
uniform sampler2D tex_frg_13;
uniform sampler2D tex_frg_10 : hint_normal;


// DeepParallax
uniform sampler2D texture_parallax_default : hint_black;

void deep_parallax(in vec3 uv_in, in sampler2D depth_texture, in float depth_scale, in float min_layers, in float max_layers, in vec3 vertex, in vec3 normal, in vec3 tangent, in vec3 binormal, in vec3 depth_flip, out vec3 uv_out) {
	vec3 view_dir = normalize(normalize(-vertex) * mat3( tangent * depth_flip.x, -binormal * depth_flip.y, normal));
	float num_layers = mix( max_layers, min_layers, abs(dot(vec3(0.0, 0.0, 1.0), view_dir)));
	float layer_depth = 1.0 / num_layers;
	float current_layer_depth = 0.0;
	vec2 P = view_dir.xy * depth_scale;
	vec2 delta = P / num_layers;
	vec2 ofs = uv_in.xy;
	float depth = textureLod(depth_texture, ofs, 0.0).r;
	float current_depth = 0.0;
	while(current_depth < depth) {
		ofs -= delta;
		depth = textureLod(depth_texture, ofs, 0.0).r;
		current_depth += layer_depth;
	}
	vec2 prev_ofs = ofs + delta;
	float after_depth  = depth - current_depth;
	float before_depth = textureLod(depth_texture, prev_ofs, 0.0).r - current_depth + layer_depth;
	float weight = after_depth / (after_depth - before_depth);
	uv_out.xy = mix(ofs, prev_ofs, weight);
}
// GlobalExpression:0
	/*The parallax texture must be passed as sampler2D from a
	TextureUniform node. The texture can be set in the 
	Shader params in the inspector panel */
// GlobalExpression:1
	// Simply use the output 
	// as uv for other textures

void vertex() {
// Output:0

}

void fragment() {
// TextureUniform:23
	vec3 n_out23p0;
	float n_out23p1;
	{
		vec4 n_tex_read = texture(ParallaxTexture, UV.xy);
		n_out23p0 = n_tex_read.rgb;
		n_out23p1 = n_tex_read.a;
	}

// Scalar:6
	float n_out6p0 = 0.180000;

// DeepParallax:21
	float n_in21p3 = 8.00000;
	float n_in21p4 = 32.00000;
	vec3 n_out21p0;
	{
		deep_parallax(vec3(UV, 0.0), ParallaxTexture, n_out6p0, n_in21p3, n_in21p4, VERTEX, NORMAL, TANGENT, BINORMAL, vec3(1.0, 1.0, 0.0), n_out21p0);
	}

// Texture:2
	vec4 tex_frg_2_read = texture(tex_frg_2, n_out21p0.xy);
	vec3 n_out2p0 = tex_frg_2_read.rgb;
	float n_out2p1 = tex_frg_2_read.a;

// Texture:14
	vec4 tex_frg_14_read = texture(tex_frg_14, n_out21p0.xy);
	vec3 n_out14p0 = tex_frg_14_read.rgb;
	float n_out14p1 = tex_frg_14_read.a;

// VectorDecompose:16
	float n_out16p0 = n_out14p0.x;
	float n_out16p1 = n_out14p0.y;
	float n_out16p2 = n_out14p0.z;

// ScalarOp:15
	float n_in15p1 = 0.86000;
	float n_out15p0 = n_out16p0 * n_in15p1;

// Scalar:12
	float n_out12p0 = 0.470000;

// Scalar:17
	float n_out17p0 = 0.500000;

// Texture:13
	vec4 tex_frg_13_read = texture(tex_frg_13, n_out21p0.xy);
	vec3 n_out13p0 = tex_frg_13_read.rgb;
	float n_out13p1 = tex_frg_13_read.a;

// Texture:10
	vec4 tex_frg_10_read = texture(tex_frg_10, n_out21p0.xy);
	vec3 n_out10p0 = tex_frg_10_read.rgb;
	float n_out10p1 = tex_frg_10_read.a;

// Scalar:11
	float n_out11p0 = 1.000000;

// Output:0
	ALBEDO = n_out2p0;
	METALLIC = n_out15p0;
	ROUGHNESS = n_out12p0;
	SPECULAR = n_out17p0;
	AO = dot(n_out13p0, vec3(0.333333, 0.333333, 0.333333));
	NORMALMAP = n_out10p0;
	NORMALMAP_DEPTH = n_out11p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -2105, 442 )
nodes/fragment/0/position = Vector2( -540, 360 )
nodes/fragment/2/node = SubResource( 58 )
nodes/fragment/2/position = Vector2( -1060, 80 )
nodes/fragment/6/node = SubResource( 62 )
nodes/fragment/6/position = Vector2( -1680, 1060 )
nodes/fragment/10/node = SubResource( 48 )
nodes/fragment/10/position = Vector2( -1100, 960 )
nodes/fragment/11/node = SubResource( 49 )
nodes/fragment/11/position = Vector2( -1120, 1180 )
nodes/fragment/12/node = SubResource( 50 )
nodes/fragment/12/position = Vector2( -1100, 580 )
nodes/fragment/13/node = SubResource( 51 )
nodes/fragment/13/position = Vector2( -1100, 720 )
nodes/fragment/14/node = SubResource( 52 )
nodes/fragment/14/position = Vector2( -1100, 340 )
nodes/fragment/15/node = SubResource( 53 )
nodes/fragment/15/position = Vector2( -900, 420 )
nodes/fragment/16/node = SubResource( 54 )
nodes/fragment/16/position = Vector2( -900, 320 )
nodes/fragment/17/node = SubResource( 55 )
nodes/fragment/17/position = Vector2( -1100, 640 )
nodes/fragment/18/node = SubResource( 56 )
nodes/fragment/18/position = Vector2( -2060, 640 )
nodes/fragment/18/size = Vector2( 569, 136 )
nodes/fragment/18/input_ports = ""
nodes/fragment/18/output_ports = ""
nodes/fragment/18/expression = "/*The parallax texture must be passed as sampler2D from a
TextureUniform node. The texture can be set in the 
Shader params in the inspector panel */"
nodes/fragment/19/node = SubResource( 57 )
nodes/fragment/19/position = Vector2( -1520, 480 )
nodes/fragment/19/size = Vector2( 304, 143 )
nodes/fragment/19/input_ports = ""
nodes/fragment/19/output_ports = ""
nodes/fragment/19/expression = "// Simply use the output 
// as uv for other textures"
nodes/fragment/20/node = SubResource( 59 )
nodes/fragment/20/position = Vector2( -1400, 940 )
nodes/fragment/21/node = SubResource( 60 )
nodes/fragment/21/position = Vector2( -1400, 640 )
nodes/fragment/23/node = SubResource( 61 )
nodes/fragment/23/position = Vector2( -1800, 820 )
nodes/fragment/connections = PoolIntArray( 2, 0, 0, 0, 10, 0, 0, 8, 11, 0, 0, 9, 12, 0, 0, 3, 13, 0, 0, 6, 14, 0, 16, 0, 15, 0, 0, 2, 16, 0, 15, 0, 17, 0, 0, 4, 6, 0, 20, 2, 21, 0, 10, 0, 21, 0, 13, 0, 21, 0, 14, 0, 21, 0, 2, 0, 6, 0, 21, 2, 23, 2, 21, 1, 23, 0, 20, 1 )

[sub_resource type="ShaderMaterial" id=64]
shader = SubResource( 63 )
shader_param/ParallaxTexture = ExtResource( 6 )

[sub_resource type="VisualShaderNodeCustom" id=65]
default_input_values = [ 2, 4.0 ]
script = ExtResource( 2 )

[sub_resource type="VisualShaderNodeColorConstant" id=66]
constant = Color( 0.117647, 0.952941, 0, 1 )

[sub_resource type="VisualShaderNodeCustom" id=67]
default_input_values = [ 2, 4.0 ]
script = ExtResource( 3 )

[sub_resource type="VisualShader" id=68]
code = "shader_type spatial;


// EmissionAdd

void emission_add(in vec3 emission_color, in vec3 emission_tex, in float energy, out vec3 emission) {
	emission = (emission_color + emission_tex) * energy;
}

void vertex() {
// Output:0

}

void fragment() {
// Color:3
	vec3 n_out3p0 = vec3(0.117647, 0.952941, 0.000000);
	float n_out3p1 = 1.000000;

// EmissionAdd:2
	float n_in2p2 = 4.00000;
	vec3 n_out2p0;
	{
		emission_add(n_out3p0, vec3(0.0, 0.0, 0.0), n_in2p2, n_out2p0);
	}

// Output:0
	EMISSION = n_out2p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -116, 233 )
nodes/fragment/0/position = Vector2( 460, 180 )
nodes/fragment/2/node = SubResource( 65 )
nodes/fragment/2/position = Vector2( 160, 260 )
nodes/fragment/3/node = SubResource( 66 )
nodes/fragment/3/position = Vector2( -20, 300 )
nodes/fragment/5/node = SubResource( 67 )
nodes/fragment/5/position = Vector2( 160, 360 )
nodes/fragment/connections = PoolIntArray( 3, 0, 5, 0, 3, 0, 2, 0, 2, 0, 0, 5 )

[sub_resource type="ShaderMaterial" id=69]
shader = SubResource( 68 )

[sub_resource type="VisualShaderNodeTexture" id=70]
texture = ExtResource( 5 )
texture_type = 2

[sub_resource type="VisualShaderNodeColorConstant" id=71]
constant = Color( 1, 1, 1, 0 )

[sub_resource type="VisualShaderNodeScalarConstant" id=72]

[sub_resource type="VisualShaderNodeScalarConstant" id=73]

[sub_resource type="VisualShaderNodeScalarConstant" id=74]
constant = 0.5

[sub_resource type="VisualShaderNodeCustom" id=75]
default_input_values = [ 1, 0.05, 2, 0.05, 4, 0.05 ]
script = ExtResource( 4 )

[sub_resource type="VisualShaderNodeScalarConstant" id=76]
constant = 0.1

[sub_resource type="VisualShader" id=77]
code = "shader_type spatial;
render_mode depth_draw_always;

uniform sampler2D tex_frg_10 : hint_normal;


// Refraction

void refraction(in float texture_value, in float refraction_scale, in float roughness, in vec3 albedo_in, in float alpha, in vec3 emission_in, in vec3 ref_normal, in vec2 screen_uv, in sampler2D screen_texture, out vec3 albedo_out, out vec3 emission_out) { 
	vec2 ref_ofs = screen_uv.xy - ref_normal.xy * texture_value * refraction_scale;
	float ref_amount = 1.0 - alpha;
	emission_out = emission_in + textureLod(screen_texture, ref_ofs, roughness * 8.0).rgb * ref_amount;
	albedo_out = albedo_in * vec3(1.0 - ref_amount);
}

void vertex() {
// Output:0

}

void fragment() {
// Texture:10
	vec4 tex_frg_10_read = texture(tex_frg_10, UV.xy);
	vec3 n_out10p0 = tex_frg_10_read.rgb;
	float n_out10p1 = tex_frg_10_read.a;

// Scalar:9
	float n_out9p0 = 0.100000;

// Scalar:4
	float n_out4p0 = 0.000000;

// Color:2
	vec3 n_out2p0 = vec3(1.000000, 1.000000, 1.000000);
	float n_out2p1 = 0.000000;

// Refraction:8
	vec3 n_out8p0;
	vec3 n_out8p1;
	{
		refraction(dot(n_out10p0, vec3(0.333333, 0.333333, 0.333333)), n_out9p0, n_out4p0, n_out2p0, n_out2p1, vec3(0.0, 0.0, 0.0), NORMAL, SCREEN_UV, SCREEN_TEXTURE, n_out8p0, n_out8p1);
	}

// Scalar:3
	float n_out3p0 = 0.000000;

// Scalar:5
	float n_out5p0 = 0.500000;

// Output:0
	ALBEDO = n_out8p0;
	METALLIC = n_out3p0;
	ROUGHNESS = n_out4p0;
	SPECULAR = n_out5p0;
	EMISSION = n_out8p1;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -218, -51 )
modes/depth_draw = 1
nodes/fragment/0/position = Vector2( 400, 120 )
nodes/fragment/2/node = SubResource( 71 )
nodes/fragment/2/position = Vector2( -100, 100 )
nodes/fragment/3/node = SubResource( 72 )
nodes/fragment/3/position = Vector2( -100, 200 )
nodes/fragment/4/node = SubResource( 73 )
nodes/fragment/4/position = Vector2( -100, 280 )
nodes/fragment/5/node = SubResource( 74 )
nodes/fragment/5/position = Vector2( -100, 360 )
nodes/fragment/8/node = SubResource( 75 )
nodes/fragment/8/position = Vector2( 140, 20 )
nodes/fragment/9/node = SubResource( 76 )
nodes/fragment/9/position = Vector2( -100, 20 )
nodes/fragment/10/node = SubResource( 70 )
nodes/fragment/10/position = Vector2( -100, -200 )
nodes/fragment/connections = PoolIntArray( 3, 0, 0, 2, 5, 0, 0, 4, 4, 0, 0, 3, 8, 0, 0, 0, 2, 0, 8, 3, 2, 1, 8, 4, 8, 1, 0, 5, 4, 0, 8, 2, 9, 0, 8, 1, 10, 0, 8, 0 )

[sub_resource type="ShaderMaterial" id=78]
shader = SubResource( 77 )

[sub_resource type="VisualShaderNodeScalarConstant" id=79]

[sub_resource type="VisualShaderNodeTextureUniformTriplanar" id=80]
uniform_name = "normal_map"
texture_type = 2

[sub_resource type="VisualShaderNodeCustom" id=81]
default_input_values = [ 1, 1.5, 2, 0.2, 4, 1.0 ]
script = ExtResource( 26 )

[sub_resource type="VisualShaderNodeScalarConstant" id=82]
constant = 1.5

[sub_resource type="VisualShaderNodeVec3Constant" id=83]
constant = Vector3( 1, 1, 1 )

[sub_resource type="VisualShaderNodeCustom" id=84]
script = ExtResource( 27 )

[sub_resource type="VisualShaderNodeScalarConstant" id=85]
constant = 0.2

[sub_resource type="VisualShaderNodeScalarConstant" id=86]
constant = 0.1

[sub_resource type="VisualShaderNodeScalarUniform" id=87]
uniform_name = "thickness"

[sub_resource type="VisualShader" id=88]
code = "shader_type spatial;
uniform float thickness;
uniform sampler2D normal_map : hint_normal;


// TRIPLANAR FUNCTION GLOBAL CODE
	vec4 triplanar_texture(sampler2D p_sampler, vec3 p_weights, vec3 p_triplanar_pos) {
		vec4 samp = vec4(0.0);
		samp += texture(p_sampler, p_triplanar_pos.xy) * p_weights.z;
		samp += texture(p_sampler, p_triplanar_pos.xz) * p_weights.y;
		samp += texture(p_sampler, p_triplanar_pos.zy * vec2(-1.0, 1.0)) * p_weights.x;
		return samp;
	}

	uniform vec3 triplanar_scale = vec3(1.0, 1.0, 1.0);
	uniform vec3 triplanar_offset;
	uniform float triplanar_sharpness = 0.5;

	varying vec3 triplanar_power_normal;
	varying vec3 triplanar_pos;
// ReadNormalMap

// Pulled straight from Godot's scene.glsl file
vec3 read_normalmap(in vec3 normalmap, in vec3 normal, in vec3 tangent, in vec3 binormal, in float normaldepth) {
	normalmap.xy = normalmap.xy * 2.0 - 1.0;
	normalmap.z = sqrt(max(0.0, 1.0 - dot(normalmap.xy, normalmap.xy))); //always ignore Z, as it can be RG packed, Z may be pos/neg, etc.
	
	return normalize(mix(normal, tangent * normalmap.x + binormal * normalmap.y + normal * normalmap.z, normaldepth));
}
// ScreenSpaceRefraction

const int SSR_MAX_STEPS = 256;

vec3 line_plane_intersect(vec3 lineorigin, vec3 linedirection, vec3 planeorigin, vec3 planenormal) {
	float dist = dot(planenormal, planeorigin - lineorigin) / dot(planenormal, linedirection);
	return lineorigin + linedirection * dist;
}

float line_unit_box_intersect_dist(vec3 lineorigin, vec3 linedirection) {
  /* https://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/
   */
  vec3 firstplane = (vec3(1.0) - lineorigin) / linedirection;
  vec3 secondplane = (vec3(-1.0) - lineorigin) / linedirection;
  vec3 furthestplane = max(firstplane, secondplane);

  return min(furthestplane.x, min(furthestplane.y, furthestplane.z));
}

vec3 get_specular_refraction_dominant_dir(vec3 N, vec3 V, float ssr_roughness, float ssr_ior) {
	/* TODO: This a bad approximation. Better approximation should fit
	* the refracted vector and ssr_roughness into the best prefiltered reflection
	* lobe. */
	/* Correct the ssr_ior for ssr_ior < 1.0 to not see the abrupt delimitation or the TIR */
	ssr_ior = (ssr_ior < 1.0) ? mix(ssr_ior, 1.0, ssr_roughness) : ssr_ior;
	float eta = 1.0 / ssr_ior;
	
	float NV = dot(N, -V);
	
	/* Custom Refraction. */
	float k = 1.0 - eta * eta * (1.0 - NV * NV);
	k = max(0.0, k); /* Only this changes. */
	vec3 R = eta * -V - (eta * NV + sqrt(k)) * N;
	
	return R;
}

vec3 project_point(mat4 projection_matrix, vec3 point) {
	vec4 ndc = projection_matrix * vec4(point, 1.0);
	return ndc.xyz / ndc.w;
}

float F_eta(float eta, float cos_theta) {
	/* compute fresnel reflectance without explicitly computing
	* the refracted direction */
	float c = abs(cos_theta);
	float g = eta * eta - 1.0 + c * c;
	float result;
	
	if (g > 0.0) {
		g = sqrt(g);
		vec2 g_c = vec2(g) + vec2(c, -c);
		float A = g_c.y / g_c.x;
		A *= A;
		g_c *= c;
		float B = (g_c.y - 1.0) / (g_c.x + 1.0);
		B *= B;
		result = 0.5 * A * (1.0 + B);
	} else {
		result = 1.0; /* TIR (no refracted component) */
	}
	
	return result;
}

void prepare_raycast(mat4 projection_matrix, vec3 ray_origin, vec3 ray_dir, float ssr_thickness, vec2 pixel_size, out vec4 ss_step, out vec4 ss_ray, out float max_time) {
	/* Negate the ray direction if it goes towards the camera.
	* This way we don't need to care if the projected point
	* is behind the near plane. */
	float z_sign = -sign(ray_dir.z);
	vec3 ray_end = ray_origin + z_sign * ray_dir;
	
	/* Project into screen space. */
	vec4 ss_start, ss_end;
	ss_start.xyz = project_point(projection_matrix, ray_origin);
	ss_end.xyz = project_point(projection_matrix, ray_end);
	
	/* We interpolate the ray Z + ssr_thickness values to check if depth is within threshold. */
	ray_origin.z -= ssr_thickness;
	ray_end.z -= ssr_thickness;
	ss_start.w = project_point(projection_matrix, ray_origin).z;
	ss_end.w = project_point(projection_matrix, ray_end).z;
	
	/* XXX This is a hack. A better method is welcome! */
	/* We take the delta between the offsetted depth and the depth and subtract it from the ray
	* depth. This will change the world space ssr_thickness appearance a bit but we can have negative
	* values without worries. We cannot do this in viewspace because of the perspective division. */
	ss_start.w = 2.0 * ss_start.z - ss_start.w;
	ss_end.w = 2.0 * ss_end.z - ss_end.w;
	
	ss_step = ss_end - ss_start;
	max_time = length(ss_step.xyz);
	ss_step = z_sign * ss_step / length(ss_step.xyz);
	
	/* If the line is degenerate, make it cover at least one pixel
	* to not have to handle zero-pixel extent as a special case later */
	ss_step.xy += vec2((dot(ss_step.xy, ss_step.xy) < 0.00001) ? 0.001 : 0.0);
	
	/* Make ss_step cover one pixel. */
	ss_step /= max(abs(ss_step.x), abs(ss_step.y));
	ss_step *= (abs(ss_step.x) > abs(ss_step.y)) ? pixel_size.x : pixel_size.y;
	
	/* Clip to segment's end. */
	max_time /= length(ss_step.xyz);
	
	/* Clipping to frustum sides. */
	max_time = min(max_time, line_unit_box_intersect_dist(ss_start.xyz, ss_step.xyz));
	
	/* Convert to texture coords. Z component included
	* since this is how it's stored in the depth buffer.
	* 4th component how far we are on the ray */
	ss_ray = ss_start * 0.5 + 0.5;
	ss_step *= 0.5;
	
	/* take the center of the texel. */
}

// #define GROUPED_FETCHES /* is still slower, need to see where is the bottleneck. */
/* Return the hit position, and negate the z component (making it positive) if not hit occurred. */
/* __ray_dir__ is the ray direction premultiplied by it's maximum length */
vec3 raycast(mat4 projection_matrix, sampler2D depth_texture, vec3 ray_origin, vec3 ray_dir, float ssr_thickness, float ray_jitter, float trace_quality, float ssr_roughness, bool discard_backface) {
	vec4 ss_step, ss_start;
	float max_time;
	prepare_raycast(projection_matrix, ray_origin, ray_dir, ssr_thickness, 1.0 / vec2(textureSize(depth_texture, 0)), ss_step, ss_start, max_time);
	
	float max_trace_time = max(0.01, max_time - 0.01);
	
	/* x : current_time, y: previous_time, z: current_delta, w: previous_delta */
	vec4 times_and_deltas = vec4(0.0);
	
	float ray_time = 0.0;
	float depth_sample = textureLod(depth_texture, ss_start.xy, 0.0).x;
	times_and_deltas.z = depth_sample - ss_start.z;
	
	float lod_fac = clamp(sqrt(ssr_roughness) * 2.0 - 0.4, 0.0, 1.0);
	bool hit = false;
	float iter;
	for(iter = 1.0; !hit && (ray_time < max_time) && (iter < float(SSR_MAX_STEPS)); iter++) {
		/* Minimum stride of 2 because we are using half res minmax zbuffer. */
		float stride = max(1.0, iter * trace_quality) * 2.0;
		float lod = log2(stride * 0.5 * trace_quality) * lod_fac;
		ray_time += stride;
		
		/* Save previous values. */
		times_and_deltas.xyzw = times_and_deltas.yxwz;
		
		float jit_stride = mix(2.0, stride, ray_jitter);
		
		times_and_deltas.x = min(ray_time + jit_stride, max_trace_time);
		vec4 ss_ray = ss_start + ss_step * times_and_deltas.x;
		
		depth_sample = textureLod(depth_texture, ss_ray.xy, lod).x;
		
		float prev_w = ss_start.w + ss_step.w * times_and_deltas.y;
		times_and_deltas.z = depth_sample - ss_ray.z;
		hit = (times_and_deltas.z <= 0.0) && (prev_w <= depth_sample);
	}
	
	if (discard_backface) {
		/* Discard backface hits */
		hit = hit && (times_and_deltas.w > 0.0);
	}
	
	/* Reject hit if background. */
	hit = hit && (depth_sample != 1.0);
	
	times_and_deltas.x = hit ? mix(times_and_deltas.y, times_and_deltas.x, clamp(times_and_deltas.w / (times_and_deltas.w - times_and_deltas.z), 0.0, 1.0)) : times_and_deltas.x;
	ray_time = hit ? times_and_deltas.x : ray_time;
	
	/* Clip to frustum. */
	ray_time = max(0.001, min(ray_time, max_time - 1.5));
	
	vec4 ss_ray = ss_start + ss_step * ray_time;
	
	/* Tag Z if ray failed. */
//	ss_ray.z *= (hit) ? 1.0 : -1.0;
	return ss_ray.xyz;
}

float screen_border_mask(vec2 hit_co) {
	const float ssrBorderFac = 0.1;
	
	const float margin = 0.003;
	float atten = ssrBorderFac + margin; /* Screen percentage */
	hit_co = smoothstep(margin, atten, hit_co) * (1.0 - smoothstep(1.0 - atten, 1.0 - margin, hit_co));
	float screenfade = hit_co.x * hit_co.y;
	return screenfade;
}

vec4 ssr(vec3 position, mat4 projection_matrix, mat4 view_matrix, sampler2D screen_texture, sampler2D depth_texture, vec3 N, vec3 V, float ssr_ior, float ssr_roughnessSquared) {
	float a2 = max(5e-6, ssr_roughnessSquared * ssr_roughnessSquared);
	
	vec3 H = N;
	float pdf = 0.0;
	
	vec3 vV = V;
	float eta = 1.0 / ssr_ior;
	if (dot(H, V) < 0.0) {
		H = -H;
		eta = ssr_ior;
	}
	
	vec3 R = refract(-V, H, 1.0 / ssr_ior);
	
	R = (view_matrix * vec4(R, 0.0)).xyz;
	
	const float ssrssr_thickness = 1.0;
	const float ssrQuality = 0.0;
	
	vec3 hit_pos = raycast(projection_matrix, depth_texture, position, R * 1e16, ssrssr_thickness, 0.0, ssrQuality, ssr_roughnessSquared, false);
	
	if ((hit_pos.z > 0.0) && (F_eta(ssr_ior, dot(H, V)) < 1.0)) {
		vec2 hit_uvs = project_point(projection_matrix, hit_pos).xy * 0.5 + 0.5;
		
		vec3 spec = textureLod(screen_texture, hit_pos.xy, ssr_roughnessSquared * 8.0).xyz;
		float mask = screen_border_mask(hit_uvs);
		return vec4(spec, mask);
	}
	
	return vec4(0.0);
}

void screenspace_refraction(in float ssr_ior, in float ssr_roughness, in float ssr_thickness, in vec3 albedo_in, in float alpha_in, in vec3 emission_in, in vec2 screen_uv, in sampler2D screen_texture, in sampler2D depth_texture, in vec3 view, in vec3 normal, in vec3 position, in mat4 view_matrix, in mat4 camera_matrix, in mat4 projection_matrix, out vec3 albedo_out, out vec3 emission_out) { 
	vec3 V = (camera_matrix * vec4(view, 0.0)).xyz;
	vec3 N = (camera_matrix * vec4(normal, 0.0)).xyz;
	vec3 world_pos = (camera_matrix * vec4(position, 1.0)).xyz;
	
	/* Refract the view vector using the depth heuristic.
	* Then later Refract a second time the already refracted
	* ray using the inverse ssr_ior. */
	float final_ior = (ssr_thickness > 0.0) ? 1.0 / ssr_ior : ssr_ior;
	vec3 refr_V = (ssr_thickness > 0.0) ? -refract(-V, N, final_ior) : V;
	vec3 refr_pos = (ssr_thickness > 0.0) ?
			line_plane_intersect(world_pos, refr_V, world_pos - N * ssr_thickness, N) :
			world_pos;
	vec3 refr_dir = get_specular_refraction_dominant_dir(N, refr_V, ssr_roughness, final_ior);
	
	/* ---------------------------- */
	/*   Screen Space Refraction    */
	/* ---------------------------- */
	/* Find approximated position of the 2nd refraction event. */
	vec3 refr_vpos = (ssr_thickness > 0.0) ? (view_matrix * vec4(refr_pos, 1.0)).xyz :
			position;
	vec4 trans = ssr(refr_vpos, projection_matrix, view_matrix, screen_texture, depth_texture, N, refr_V, final_ior, ssr_roughness * ssr_roughness);
	trans.a *= smoothstep(1.0 + 0.2, 1.0, ssr_roughness);
	
	float fac = 1.0 - alpha_in;
	fac *= 1.0 - pow(1.0 - dot(V, N), 5.0) * (1.0 - ssr_roughness);
	
	emission_out = emission_in + trans.rgb * albedo_in * fac;
	albedo_out = albedo_in * 1.0 - fac;
}


void vertex() {
// Output:0

	// TRIPLANAR FUNCTION VERTEX CODE
		triplanar_power_normal = pow(abs(NORMAL), vec3(triplanar_sharpness));
		triplanar_power_normal /= dot(triplanar_power_normal, vec3(1.0));
		triplanar_pos = VERTEX * triplanar_scale + triplanar_offset;
		triplanar_pos *= vec3(1.0, -1.0, 1.0);
}

void fragment() {
// Scalar:3
	float n_out3p0 = 1.500000;

// ScalarUniform:9
	float n_out9p0 = thickness;

// Scalar:8
	float n_out8p0 = 0.100000;

// Vector:4
	vec3 n_out4p0 = vec3(1.000000, 1.000000, 1.000000);

// Scalar:10
	float n_out10p0 = 0.000000;

// TextureUniformTriplanar:11
	vec3 n_out11p0;
	float n_out11p1;
	{
		vec4 n_tex_read = triplanar_texture( normal_map, triplanar_power_normal, triplanar_pos );
		n_out11p0 = n_tex_read.rgb;
		n_out11p1 = n_tex_read.a;
	}

// Scalar:7
	float n_out7p0 = 0.200000;

// ReadNormalMap:6
	vec3 n_out6p0;
	{
		n_out6p0 = read_normalmap(n_out11p0, NORMAL, TANGENT, BINORMAL, n_out7p0);
	}

// ScreenSpaceRefraction:2
	vec3 n_out2p0;
	vec3 n_out2p1;
	{
		screenspace_refraction(n_out3p0, n_out8p0, n_out9p0, n_out4p0, n_out10p0, vec3(0.0), SCREEN_UV, SCREEN_TEXTURE, DEPTH_TEXTURE, VIEW, n_out6p0, VERTEX, INV_CAMERA_MATRIX, CAMERA_MATRIX, PROJECTION_MATRIX, n_out2p0, n_out2p1);
	}

// Output:0
	ALBEDO = n_out2p0;
	ROUGHNESS = n_out8p0;
	EMISSION = n_out2p1;
	NORMAL = n_out6p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -392, 128 )
nodes/fragment/0/position = Vector2( 380, 160 )
nodes/fragment/2/node = SubResource( 81 )
nodes/fragment/2/position = Vector2( 20, 180 )
nodes/fragment/3/node = SubResource( 82 )
nodes/fragment/3/position = Vector2( -240, 160 )
nodes/fragment/4/node = SubResource( 83 )
nodes/fragment/4/position = Vector2( -380, 280 )
nodes/fragment/6/node = SubResource( 84 )
nodes/fragment/6/position = Vector2( -160, 440 )
nodes/fragment/7/node = SubResource( 85 )
nodes/fragment/7/position = Vector2( -360, 560 )
nodes/fragment/8/node = SubResource( 86 )
nodes/fragment/8/position = Vector2( -240, 80 )
nodes/fragment/9/node = SubResource( 87 )
nodes/fragment/9/position = Vector2( -240, 220 )
nodes/fragment/10/node = SubResource( 79 )
nodes/fragment/10/position = Vector2( -240, 360 )
nodes/fragment/11/node = SubResource( 80 )
nodes/fragment/11/position = Vector2( -540, 380 )
nodes/fragment/connections = PoolIntArray( 4, 0, 2, 3, 7, 0, 6, 4, 6, 0, 0, 7, 6, 0, 2, 6, 2, 0, 0, 0, 2, 1, 0, 5, 3, 0, 2, 0, 8, 0, 0, 3, 8, 0, 2, 2, 10, 0, 2, 4, 9, 0, 2, 1, 11, 0, 6, 0 )

[sub_resource type="ShaderMaterial" id=89]
shader = SubResource( 88 )
shader_param/thickness = 1.467
shader_param/triplanar_scale = Vector3( 0.5, 0.5, 0.5 )
shader_param/triplanar_offset = Vector3( 0, 0, 0 )
shader_param/triplanar_sharpness = 5.0
shader_param/normal_map = ExtResource( 5 )

[sub_resource type="VisualShaderNodeCustom" id=44]
default_input_values = [ 0, 1.0 ]
script = ExtResource( 9 )

[sub_resource type="VisualShaderNodeScalarConstant" id=45]
constant = 0.2

[sub_resource type="VisualShader" id=46]
code = "shader_type spatial;


// Dither

void dither(in vec4 fragcoord, in float fade, out float alpha_scissor) {
	int x = int(int(fragcoord.x) % 4);
	int y = int(int(fragcoord.y) % 4);
	int index = x + y * 4;
	float limit = 0.0;

	if (x < 8) {
		if (index == 0) limit = 0.0625;
		if (index == 1) limit = 0.5625;
		if (index == 2) limit = 0.1875;
		if (index == 3) limit = 0.6875;
		if (index == 4) limit = 0.8125;
		if (index == 5) limit = 0.3125;
		if (index == 6) limit = 0.9375;
		if (index == 7) limit = 0.4375;
		if (index == 8) limit = 0.25;
		if (index == 9) limit = 0.75;
		if (index == 10) limit = 0.125;
		if (index == 11) limit = 0.625;
		if (index == 12) limit = 1.0;
		if (index == 13) limit = 0.5;
		if (index == 14) limit = 0.875;
		if (index == 15) limit = 0.375;
	}
	// Workaround: Use alpha scissor > 1 for discarding because shader nodes without output will not included
	alpha_scissor = 0.0;
	if (fade < limit) {
		alpha_scissor = 1.1;
		//Discard;
	}
}

void vertex() {
// Output:0

}

void fragment() {
// Scalar:3
	float n_out3p0 = 0.200000;

// Dither:2
	float n_out2p0;
	{
		dither(FRAGCOORD, n_out3p0, n_out2p0);
	}

// Output:0
	ALPHA_SCISSOR = n_out2p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -277, 126 )
nodes/fragment/2/node = SubResource( 44 )
nodes/fragment/2/position = Vector2( 80, 520 )
nodes/fragment/3/node = SubResource( 45 )
nodes/fragment/3/position = Vector2( -140, 500 )
nodes/fragment/connections = PoolIntArray( 3, 0, 2, 0, 2, 0, 0, 18 )

[sub_resource type="ShaderMaterial" id=90]
shader = SubResource( 46 )

[sub_resource type="VisualShaderNodeCustom" id=91]
script = ExtResource( 10 )

[sub_resource type="VisualShaderNodeGlobalExpression" id=92]
size = Vector2( 478, 165 )
expression = "/* Optional you can pass depth position manually

Recommeded if depth position is used elsewhere
 so it is only calculate once (Performance) */"

[sub_resource type="VisualShaderNodeScalarConstant" id=93]

[sub_resource type="VisualShaderNodeCustom" id=94]
default_input_values = [ 0, 2.0 ]
script = ExtResource( 15 )

[sub_resource type="VisualShaderNodeInput" id=95]
input_name = "vertex"

[sub_resource type="VisualShaderNodeScalarFunc" id=96]
function = 0

[sub_resource type="VisualShaderNodeInput" id=97]
input_name = "time"

[sub_resource type="VisualShaderNodeVectorOp" id=98]

[sub_resource type="VisualShaderNodeVectorCompose" id=99]

[sub_resource type="VisualShaderNodeGlobalExpression" id=100]
size = Vector2( 499, 128 )
expression = "/* This is just for up down animation 
Distance fade is in the fragment shader */"

[sub_resource type="VisualShader" id=101]
code = "shader_type spatial;


// ProximityFade

// Use own depth_texture_world_position if it is not passed via input port
void proximity_fade_depth_pos(in sampler2D depth, in vec2 screen_uv, in mat4 inv_proj_mat, out vec3 world_position) {
	float depth_tex = textureLod(depth, screen_uv.xy, 0.0).r;
	vec4 world_pos = inv_proj_mat * vec4(screen_uv.xy * 2.0 - 1.0, depth_tex * 2.0 - 1.0, 1.0);
	world_position = world_pos.xyz / world_pos.w;
}

void proximity_fade(in vec3 world_pos, in vec3 vertex, in float fade_distance, out float alpha) {
	alpha = clamp(1.0 - smoothstep(world_pos.z + fade_distance, world_pos.z, vertex.z), 0.0, 1.0);
}
// GlobalExpression:0
	/* This is just for up down animation 
	Distance fade is in the fragment shader */
// GlobalExpression:1
	/* Optional you can pass depth position manually
	
	Recommeded if depth position is used elsewhere
	 so it is only calculate once (Performance) */

void vertex() {
// Input:2
	vec3 n_out2p0 = VERTEX;

// Input:4
	float n_out4p0 = TIME;

// ScalarFunc:3
	float n_out3p0 = sin(n_out4p0);

// VectorCompose:7
	float n_in7p0 = 0.00000;
	float n_in7p2 = 0.00000;
	vec3 n_out7p0 = vec3(n_in7p0, n_out3p0, n_in7p2);

// VectorOp:6
	vec3 n_out6p0 = n_out2p0 + n_out7p0;

// Output:0
	VERTEX = n_out6p0;

}

void fragment() {
// ProximityFade:8
	float n_in8p0 = 2.00000;
	float n_out8p0;
	{
		vec3 proximity_fade_depth_p;
		proximity_fade_depth_pos(DEPTH_TEXTURE, SCREEN_UV, INV_PROJECTION_MATRIX, proximity_fade_depth_p);
		proximity_fade(proximity_fade_depth_p, VERTEX, n_in8p0, n_out8p0);
	}

// Scalar:7
	float n_out7p0 = 0.000000;

// Output:0
	ALPHA = n_out8p0;
	ROUGHNESS = n_out7p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -390, 28 )
nodes/vertex/0/position = Vector2( 520, 120 )
nodes/vertex/2/node = SubResource( 95 )
nodes/vertex/2/position = Vector2( 120, 160 )
nodes/vertex/3/node = SubResource( 96 )
nodes/vertex/3/position = Vector2( -40, 260 )
nodes/vertex/4/node = SubResource( 97 )
nodes/vertex/4/position = Vector2( -200, 260 )
nodes/vertex/6/node = SubResource( 98 )
nodes/vertex/6/position = Vector2( 340, 160 )
nodes/vertex/7/node = SubResource( 99 )
nodes/vertex/7/position = Vector2( 140, 240 )
nodes/vertex/8/node = SubResource( 100 )
nodes/vertex/8/position = Vector2( -80, 20 )
nodes/vertex/8/size = Vector2( 499, 128 )
nodes/vertex/8/input_ports = ""
nodes/vertex/8/output_ports = ""
nodes/vertex/8/expression = "/* This is just for up down animation 
Distance fade is in the fragment shader */"
nodes/vertex/connections = PoolIntArray( 4, 0, 3, 0, 6, 0, 0, 0, 2, 0, 6, 0, 7, 0, 6, 1, 3, 0, 7, 1 )
nodes/fragment/5/node = SubResource( 91 )
nodes/fragment/5/position = Vector2( -80, 320 )
nodes/fragment/6/node = SubResource( 92 )
nodes/fragment/6/position = Vector2( -360, 140 )
nodes/fragment/6/size = Vector2( 478, 165 )
nodes/fragment/6/input_ports = ""
nodes/fragment/6/output_ports = ""
nodes/fragment/6/expression = "/* Optional you can pass depth position manually

Recommeded if depth position is used elsewhere
 so it is only calculate once (Performance) */"
nodes/fragment/7/node = SubResource( 93 )
nodes/fragment/7/position = Vector2( 200, 260 )
nodes/fragment/8/node = SubResource( 94 )
nodes/fragment/8/position = Vector2( 140, 140 )
nodes/fragment/connections = PoolIntArray( 7, 0, 0, 3, 8, 0, 0, 1 )

[sub_resource type="ShaderMaterial" id=102]
shader = SubResource( 101 )

[sub_resource type="VisualShaderNodeCustom" id=103]
default_input_values = [ 0, 1.0 ]
script = ExtResource( 9 )

[sub_resource type="VisualShaderNodeScalarConstant" id=104]

[sub_resource type="VisualShaderNodeCustom" id=105]
default_input_values = [ 0, 2.0 ]
script = ExtResource( 15 )

[sub_resource type="VisualShaderNodeVectorCompose" id=106]

[sub_resource type="VisualShaderNodeInput" id=107]
input_name = "time"

[sub_resource type="VisualShaderNodeScalarFunc" id=108]
function = 0

[sub_resource type="VisualShaderNodeInput" id=109]
input_name = "vertex"

[sub_resource type="VisualShaderNodeVectorOp" id=110]

[sub_resource type="VisualShader" id=111]
code = "shader_type spatial;


// ProximityFade

// Use own depth_texture_world_position if it is not passed via input port
void proximity_fade_depth_pos(in sampler2D depth, in vec2 screen_uv, in mat4 inv_proj_mat, out vec3 world_position) {
	float depth_tex = textureLod(depth, screen_uv.xy, 0.0).r;
	vec4 world_pos = inv_proj_mat * vec4(screen_uv.xy * 2.0 - 1.0, depth_tex * 2.0 - 1.0, 1.0);
	world_position = world_pos.xyz / world_pos.w;
}

void proximity_fade(in vec3 world_pos, in vec3 vertex, in float fade_distance, out float alpha) {
	alpha = clamp(1.0 - smoothstep(world_pos.z + fade_distance, world_pos.z, vertex.z), 0.0, 1.0);
}
// Dither

void dither(in vec4 fragcoord, in float fade, out float alpha_scissor) {
	int x = int(int(fragcoord.x) % 4);
	int y = int(int(fragcoord.y) % 4);
	int index = x + y * 4;
	float limit = 0.0;

	if (x < 8) {
		if (index == 0) limit = 0.0625;
		if (index == 1) limit = 0.5625;
		if (index == 2) limit = 0.1875;
		if (index == 3) limit = 0.6875;
		if (index == 4) limit = 0.8125;
		if (index == 5) limit = 0.3125;
		if (index == 6) limit = 0.9375;
		if (index == 7) limit = 0.4375;
		if (index == 8) limit = 0.25;
		if (index == 9) limit = 0.75;
		if (index == 10) limit = 0.125;
		if (index == 11) limit = 0.625;
		if (index == 12) limit = 1.0;
		if (index == 13) limit = 0.5;
		if (index == 14) limit = 0.875;
		if (index == 15) limit = 0.375;
	}
	// Workaround: Use alpha scissor > 1 for discarding because shader nodes without output will not included
	alpha_scissor = 0.0;
	if (fade < limit) {
		alpha_scissor = 1.1;
		//Discard;
	}
}

void vertex() {
// Input:5
	vec3 n_out5p0 = VERTEX;

// Input:3
	float n_out3p0 = TIME;

// ScalarFunc:4
	float n_out4p0 = sin(n_out3p0);

// VectorCompose:2
	float n_in2p0 = 0.00000;
	float n_in2p2 = 0.00000;
	vec3 n_out2p0 = vec3(n_in2p0, n_out4p0, n_in2p2);

// VectorOp:6
	vec3 n_out6p0 = n_out5p0 + n_out2p0;

// Output:0
	VERTEX = n_out6p0;

}

void fragment() {
// Scalar:8
	float n_out8p0 = 0.000000;

// ProximityFade:9
	float n_in9p0 = 2.00000;
	float n_out9p0;
	{
		vec3 proximity_fade_depth_p;
		proximity_fade_depth_pos(DEPTH_TEXTURE, SCREEN_UV, INV_PROJECTION_MATRIX, proximity_fade_depth_p);
		proximity_fade(proximity_fade_depth_p, VERTEX, n_in9p0, n_out9p0);
	}

// Dither:7
	float n_out7p0;
	{
		dither(FRAGCOORD, n_out9p0, n_out7p0);
	}

// Output:0
	ROUGHNESS = n_out8p0;
	ALPHA_SCISSOR = n_out7p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -263, 124 )
nodes/vertex/2/node = SubResource( 106 )
nodes/vertex/2/position = Vector2( -20, 180 )
nodes/vertex/3/node = SubResource( 107 )
nodes/vertex/3/position = Vector2( -360, 180 )
nodes/vertex/4/node = SubResource( 108 )
nodes/vertex/4/position = Vector2( -200, 240 )
nodes/vertex/5/node = SubResource( 109 )
nodes/vertex/5/position = Vector2( 20, 80 )
nodes/vertex/6/node = SubResource( 110 )
nodes/vertex/6/position = Vector2( 184, 103 )
nodes/vertex/connections = PoolIntArray( 6, 0, 0, 0, 3, 0, 4, 0, 4, 0, 2, 1, 5, 0, 6, 0, 2, 0, 6, 1 )
nodes/fragment/0/position = Vector2( 640, 160 )
nodes/fragment/7/node = SubResource( 103 )
nodes/fragment/7/position = Vector2( 380, 540 )
nodes/fragment/8/node = SubResource( 104 )
nodes/fragment/8/position = Vector2( 400, 220 )
nodes/fragment/9/node = SubResource( 105 )
nodes/fragment/9/position = Vector2( 120, 480 )
nodes/fragment/connections = PoolIntArray( 7, 0, 0, 18, 8, 0, 0, 3, 9, 0, 7, 0 )

[sub_resource type="ShaderMaterial" id=112]
shader = SubResource( 111 )

[sub_resource type="VisualShaderNodeScalarConstant" id=113]
constant = 2.0

[sub_resource type="VisualShaderNodeScalarConstant" id=114]

[sub_resource type="VisualShaderNodeCustom" id=115]
default_input_values = [ 0, 0, 1, 10 ]
script = ExtResource( 8 )

[sub_resource type="VisualShaderNodeScalarConstant" id=116]
constant = 4.0

[sub_resource type="VisualShader" id=117]
code = "shader_type spatial;


// DistanceFade

void distance_fade(in vec3 vertex, in float distance_min, in float distance_max, out float alpha) {
	alpha = clamp(smoothstep(distance_min, distance_max, -vertex.z), 0.0, 1.0);
}

void vertex() {
// Output:0

}

void fragment() {
// Scalar:3
	float n_out3p0 = 2.000000;

// Scalar:9
	float n_out9p0 = 4.000000;

// DistanceFade:8
	float n_out8p0;
	{
		distance_fade(VERTEX, n_out3p0, n_out9p0, n_out8p0);
	}

// Scalar:7
	float n_out7p0 = 0.000000;

// Output:0
	ALPHA = n_out8p0;
	ROUGHNESS = n_out7p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -453.668, -13.5 )
nodes/fragment/3/node = SubResource( 113 )
nodes/fragment/3/position = Vector2( -280, 100 )
nodes/fragment/7/node = SubResource( 114 )
nodes/fragment/7/position = Vector2( 200, 220 )
nodes/fragment/8/node = SubResource( 115 )
nodes/fragment/8/position = Vector2( -60, 160 )
nodes/fragment/9/node = SubResource( 116 )
nodes/fragment/9/position = Vector2( -280, 180 )
nodes/fragment/connections = PoolIntArray( 7, 0, 0, 3, 3, 0, 8, 0, 9, 0, 8, 1, 8, 0, 0, 1 )

[sub_resource type="ShaderMaterial" id=118]
shader = SubResource( 117 )

[sub_resource type="VisualShaderNodeCustom" id=119]
default_input_values = [ 0, 1.0 ]
script = ExtResource( 9 )

[sub_resource type="VisualShaderNodeScalarConstant" id=120]
constant = 2.0

[sub_resource type="VisualShaderNodeScalarConstant" id=121]

[sub_resource type="VisualShaderNodeCustom" id=122]
default_input_values = [ 0, 0, 1, 10 ]
script = ExtResource( 8 )

[sub_resource type="VisualShaderNodeScalarConstant" id=123]
constant = 4.0

[sub_resource type="VisualShader" id=124]
code = "shader_type spatial;


// DistanceFade

void distance_fade(in vec3 vertex, in float distance_min, in float distance_max, out float alpha) {
	alpha = clamp(smoothstep(distance_min, distance_max, -vertex.z), 0.0, 1.0);
}
// Dither

void dither(in vec4 fragcoord, in float fade, out float alpha_scissor) {
	int x = int(int(fragcoord.x) % 4);
	int y = int(int(fragcoord.y) % 4);
	int index = x + y * 4;
	float limit = 0.0;

	if (x < 8) {
		if (index == 0) limit = 0.0625;
		if (index == 1) limit = 0.5625;
		if (index == 2) limit = 0.1875;
		if (index == 3) limit = 0.6875;
		if (index == 4) limit = 0.8125;
		if (index == 5) limit = 0.3125;
		if (index == 6) limit = 0.9375;
		if (index == 7) limit = 0.4375;
		if (index == 8) limit = 0.25;
		if (index == 9) limit = 0.75;
		if (index == 10) limit = 0.125;
		if (index == 11) limit = 0.625;
		if (index == 12) limit = 1.0;
		if (index == 13) limit = 0.5;
		if (index == 14) limit = 0.875;
		if (index == 15) limit = 0.375;
	}
	// Workaround: Use alpha scissor > 1 for discarding because shader nodes without output will not included
	alpha_scissor = 0.0;
	if (fade < limit) {
		alpha_scissor = 1.1;
		//Discard;
	}
}

void vertex() {
// Output:0

}

void fragment() {
// Scalar:7
	float n_out7p0 = 0.000000;

// Scalar:3
	float n_out3p0 = 2.000000;

// Scalar:9
	float n_out9p0 = 4.000000;

// DistanceFade:8
	float n_out8p0;
	{
		distance_fade(VERTEX, n_out3p0, n_out9p0, n_out8p0);
	}

// Dither:10
	float n_out10p0;
	{
		dither(FRAGCOORD, n_out8p0, n_out10p0);
	}

// Output:0
	ROUGHNESS = n_out7p0;
	ALPHA_SCISSOR = n_out10p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -491, -10 )
nodes/fragment/3/node = SubResource( 120 )
nodes/fragment/3/position = Vector2( -420, 400 )
nodes/fragment/7/node = SubResource( 121 )
nodes/fragment/7/position = Vector2( 200, 220 )
nodes/fragment/8/node = SubResource( 122 )
nodes/fragment/8/position = Vector2( -200, 460 )
nodes/fragment/9/node = SubResource( 123 )
nodes/fragment/9/position = Vector2( -420, 480 )
nodes/fragment/10/node = SubResource( 119 )
nodes/fragment/10/position = Vector2( 60, 500 )
nodes/fragment/connections = PoolIntArray( 7, 0, 0, 3, 10, 0, 0, 18, 8, 0, 10, 0, 9, 0, 8, 1, 3, 0, 8, 0 )

[sub_resource type="ShaderMaterial" id=125]
shader = SubResource( 124 )

[sub_resource type="CubeMesh" id=126]

[sub_resource type="VisualShaderNodeScalarConstant" id=127]
constant = 0.5

[sub_resource type="VisualShaderNodeScalarConstant" id=128]

[sub_resource type="VisualShaderNodeScalarFunc" id=129]
function = 27

[sub_resource type="VisualShaderNodeInput" id=130]
input_name = "time"

[sub_resource type="VisualShaderNodeGlobalExpression" id=131]
size = Vector2( 662, 154 )
expression = "/* angle is in radians, you can use the radians node to convert 
degrees to radians before passing it to the rotation node*/"

[sub_resource type="VisualShaderNodeScalarConstant" id=132]
constant = 45.0

[sub_resource type="VisualShaderNodeCustom" id=133]
default_input_values = [ 1, 0.0 ]
script = ExtResource( 20 )

[sub_resource type="VisualShaderNodeInput" id=134]
input_name = "vertex"

[sub_resource type="VisualShaderNodeVec3Constant" id=135]
constant = Vector3( 0.5, 1, 0.5 )

[sub_resource type="VisualShaderNodeInput" id=136]
input_name = "normal"

[sub_resource type="VisualShader" id=137]
code = "shader_type spatial;


// Rotation3D

mat4 rotation_matrix_3d(vec3 axis, float angle){
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(vec4(oc * axis.x * axis.x + c,			oc * axis.x * axis.y - axis.z * s,	oc * axis.z * axis.x + axis.y * s,	0.0),
                vec4(oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,			oc * axis.y * axis.z - axis.x * s,	0.0),
                vec4(oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, 	oc * axis.z * axis.z + c,			0.0),
                vec4(0.0,								0.0, 								0.0,								1.0));
}

void rotation_3d_normal(vec3 axis, float angle, in vec3 normal_in, out vec3 normal_out) {
	normal_out = (rotation_matrix_3d(axis, angle) * vec4(normal_in, 0.0)).xyz;
}

void rotation_3d(vec3 axis, float angle, vec3 pivot, in vec3 position_in, out vec3 position_out) {
	position_in.xyz -= pivot;
	vec4 position = vec4(position_in, 1.0);
	position_out = (rotation_matrix_3d(axis, angle) * position).xyz;
	position_out += pivot;
}
// GlobalExpression:0
	/* angle is in radians, you can use the radians node to convert 
	degrees to radians before passing it to the rotation node*/

void vertex() {
// Vector:6
	vec3 n_out6p0 = vec3(0.500000, 1.000000, 0.500000);

// Input:11
	float n_out11p0 = TIME;

// Input:3
	vec3 n_out3p0 = VERTEX;

// Input:8
	vec3 n_out8p0 = NORMAL;

// Rotation3D:14
	vec3 n_out14p0;
	vec3 n_out14p1;
	{
		rotation_3d(n_out6p0, n_out11p0, vec3(0.0, 0.0, 0.0), n_out3p0, n_out14p0);
		rotation_3d_normal(n_out6p0, n_out11p0, n_out8p0, n_out14p1);
	}

// Output:0
	VERTEX = n_out14p0;
	NORMAL = n_out14p1;

}

void fragment() {
// Scalar:2
	float n_out2p0 = 0.500000;

// Scalar:3
	float n_out3p0 = 0.000000;

// Output:0
	METALLIC = n_out2p0;
	ROUGHNESS = n_out3p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -378, 4.25 )
nodes/vertex/0/position = Vector2( 400, 200 )
nodes/vertex/3/node = SubResource( 134 )
nodes/vertex/3/position = Vector2( -140, 400 )
nodes/vertex/6/node = SubResource( 135 )
nodes/vertex/6/position = Vector2( -320, 160 )
nodes/vertex/8/node = SubResource( 136 )
nodes/vertex/8/position = Vector2( -100, 480 )
nodes/vertex/10/node = SubResource( 129 )
nodes/vertex/10/position = Vector2( -160, 340 )
nodes/vertex/11/node = SubResource( 130 )
nodes/vertex/11/position = Vector2( -140, 260 )
nodes/vertex/12/node = SubResource( 131 )
nodes/vertex/12/position = Vector2( -120, -20 )
nodes/vertex/12/size = Vector2( 662, 154 )
nodes/vertex/12/input_ports = ""
nodes/vertex/12/output_ports = ""
nodes/vertex/12/expression = "/* angle is in radians, you can use the radians node to convert 
degrees to radians before passing it to the rotation node*/"
nodes/vertex/13/node = SubResource( 132 )
nodes/vertex/13/position = Vector2( -380, 340 )
nodes/vertex/14/node = SubResource( 133 )
nodes/vertex/14/position = Vector2( 100, 260 )
nodes/vertex/connections = PoolIntArray( 13, 0, 10, 0, 14, 0, 0, 0, 11, 0, 14, 1, 3, 0, 14, 3, 6, 0, 14, 0, 14, 1, 0, 1, 8, 0, 14, 4 )
nodes/fragment/2/node = SubResource( 127 )
nodes/fragment/2/position = Vector2( 120, 200 )
nodes/fragment/3/node = SubResource( 128 )
nodes/fragment/3/position = Vector2( 120, 280 )
nodes/fragment/connections = PoolIntArray( 2, 0, 0, 2, 3, 0, 0, 3 )

[sub_resource type="ShaderMaterial" id=138]
shader = SubResource( 137 )

[sub_resource type="VisualShaderNodeScalarConstant" id=139]

[sub_resource type="VisualShaderNodeScalarConstant" id=140]
constant = 0.5

[sub_resource type="VisualShaderNodeScalarFunc" id=141]
function = 27

[sub_resource type="VisualShaderNodeInput" id=142]
input_name = "time"

[sub_resource type="VisualShaderNodeGlobalExpression" id=143]
size = Vector2( 662, 154 )
expression = "/* Rotation aroun pivot local to objects position */

/* angle is in radians, you can use the radians node to convert 
degrees to radians before passing it to the rotation node*/"

[sub_resource type="VisualShaderNodeScalarConstant" id=144]
constant = 45.0

[sub_resource type="VisualShaderNodeVec3Constant" id=145]
constant = Vector3( 0, 2, 0 )

[sub_resource type="VisualShaderNodeCustom" id=146]
default_input_values = [ 1, 0.0 ]
script = ExtResource( 20 )

[sub_resource type="VisualShaderNodeInput" id=147]
input_name = "vertex"

[sub_resource type="VisualShaderNodeVec3Constant" id=148]
constant = Vector3( 0, 0, 1 )

[sub_resource type="VisualShaderNodeInput" id=149]
input_name = "normal"

[sub_resource type="VisualShader" id=150]
code = "shader_type spatial;


// Rotation3D

mat4 rotation_matrix_3d(vec3 axis, float angle){
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(vec4(oc * axis.x * axis.x + c,			oc * axis.x * axis.y - axis.z * s,	oc * axis.z * axis.x + axis.y * s,	0.0),
                vec4(oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,			oc * axis.y * axis.z - axis.x * s,	0.0),
                vec4(oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, 	oc * axis.z * axis.z + c,			0.0),
                vec4(0.0,								0.0, 								0.0,								1.0));
}

void rotation_3d_normal(vec3 axis, float angle, in vec3 normal_in, out vec3 normal_out) {
	normal_out = (rotation_matrix_3d(axis, angle) * vec4(normal_in, 0.0)).xyz;
}

void rotation_3d(vec3 axis, float angle, vec3 pivot, in vec3 position_in, out vec3 position_out) {
	position_in.xyz -= pivot;
	vec4 position = vec4(position_in, 1.0);
	position_out = (rotation_matrix_3d(axis, angle) * position).xyz;
	position_out += pivot;
}
// GlobalExpression:0
	/* Rotation aroun pivot local to objects position */
	
	/* angle is in radians, you can use the radians node to convert 
	degrees to radians before passing it to the rotation node*/

void vertex() {
// Vector:6
	vec3 n_out6p0 = vec3(0.000000, 0.000000, 1.000000);

// Input:11
	float n_out11p0 = TIME;

// Vector:14
	vec3 n_out14p0 = vec3(0.000000, 2.000000, 0.000000);

// Input:3
	vec3 n_out3p0 = VERTEX;

// Input:8
	vec3 n_out8p0 = NORMAL;

// Rotation3D:15
	vec3 n_out15p0;
	vec3 n_out15p1;
	{
		rotation_3d(n_out6p0, n_out11p0, n_out14p0, n_out3p0, n_out15p0);
		rotation_3d_normal(n_out6p0, n_out11p0, n_out8p0, n_out15p1);
	}

// Output:0
	VERTEX = n_out15p0;
	NORMAL = n_out15p1;

}

void fragment() {
// Scalar:3
	float n_out3p0 = 0.500000;

// Scalar:2
	float n_out2p0 = 0.000000;

// Output:0
	METALLIC = n_out3p0;
	ROUGHNESS = n_out2p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -350, 105 )
nodes/vertex/0/position = Vector2( 400, 200 )
nodes/vertex/3/node = SubResource( 147 )
nodes/vertex/3/position = Vector2( -100, 420 )
nodes/vertex/6/node = SubResource( 148 )
nodes/vertex/6/position = Vector2( -280, 160 )
nodes/vertex/8/node = SubResource( 149 )
nodes/vertex/8/position = Vector2( -100, 500 )
nodes/vertex/10/node = SubResource( 141 )
nodes/vertex/10/position = Vector2( -320, 260 )
nodes/vertex/11/node = SubResource( 142 )
nodes/vertex/11/position = Vector2( -140, 260 )
nodes/vertex/12/node = SubResource( 143 )
nodes/vertex/12/position = Vector2( -120, -20 )
nodes/vertex/12/size = Vector2( 662, 154 )
nodes/vertex/12/input_ports = ""
nodes/vertex/12/output_ports = ""
nodes/vertex/12/expression = "/* Rotation aroun pivot local to objects position */

/* angle is in radians, you can use the radians node to convert 
degrees to radians before passing it to the rotation node*/"
nodes/vertex/13/node = SubResource( 144 )
nodes/vertex/13/position = Vector2( -520, 260 )
nodes/vertex/14/node = SubResource( 145 )
nodes/vertex/14/position = Vector2( -280, 320 )
nodes/vertex/15/node = SubResource( 146 )
nodes/vertex/15/position = Vector2( 188, 256 )
nodes/vertex/connections = PoolIntArray( 15, 0, 0, 0, 15, 1, 0, 1, 8, 0, 15, 4, 3, 0, 15, 3, 14, 0, 15, 2, 13, 0, 10, 0, 11, 0, 15, 1, 6, 0, 15, 0 )
nodes/fragment/2/node = SubResource( 139 )
nodes/fragment/2/position = Vector2( -20, 160 )
nodes/fragment/3/node = SubResource( 140 )
nodes/fragment/3/position = Vector2( -20, 100 )
nodes/fragment/connections = PoolIntArray( 2, 0, 0, 3, 3, 0, 0, 2 )

[sub_resource type="ShaderMaterial" id=151]
shader = SubResource( 150 )

[sub_resource type="PlaneMesh" id=152]
size = Vector2( 2.5, 2.5 )

[sub_resource type="VisualShaderNodeVectorCompose" id=153]
default_input_values = [ 0, 1.0, 1, -1.0, 2, 0.0 ]

[sub_resource type="VisualShaderNodeScalarConstant" id=154]

[sub_resource type="VisualShaderNodeColorConstant" id=155]
constant = Color( 0, 0.462745, 0.690196, 0.960784 )

[sub_resource type="VisualShaderNodeScalarConstant" id=156]
constant = 0.3

[sub_resource type="VisualShaderNodeCustom" id=157]
default_input_values = [ 1, 5.0, 2, 0.5, 5, 0.0 ]
script = ExtResource( 22 )

[sub_resource type="VisualShaderNodeCustom" id=158]
default_input_values = [ 1, 5.0 ]
script = ExtResource( 21 )

[sub_resource type="VisualShaderNodeInput" id=159]
input_name = "uv"

[sub_resource type="VisualShaderNodeTexture" id=160]
texture = ExtResource( 24 )

[sub_resource type="VisualShaderNodeTexture" id=161]
texture = ExtResource( 5 )
texture_type = 2

[sub_resource type="VisualShaderNodeTexture" id=162]
texture = ExtResource( 5 )
texture_type = 2

[sub_resource type="VisualShaderNodeVectorScalarMix" id=163]

[sub_resource type="VisualShader" id=164]
code = "shader_type spatial;
uniform sampler2D tex_frg_5;
uniform sampler2D tex_frg_6 : hint_normal;
uniform sampler2D tex_frg_7 : hint_normal;


// Flowmap

void flow_map(vec3 flow_map, float blend_cycle, float speed, vec3 uv, vec3 direction, float offset, float time, out float blend_factor, out vec3 layer1, out vec3 layer2, out float flow_strength) {
	float half_cycle = blend_cycle * 0.5;
	
	float t = time * speed + offset;
	float phase1 = mod(t, blend_cycle);
	float phase2 = mod(t + half_cycle, blend_cycle);
	
	// Blend factor to mix the two layers
	blend_factor = abs(half_cycle - phase1) / half_cycle;
	
	// Offset by halfCycle to improve the animation for color
	// Not absolutely necessary for normalmaps
	phase1 -= half_cycle;
	phase2 -= half_cycle;
	
	vec2 flow = flow_map.xy * 2.0 - 1.0;
	flow *= normalize(direction.xy);
	
	layer1.xy = flow * phase1;
	layer2.xy = flow * phase2;
	
	// Flow intensity
	flow_strength = length(abs(flow));
}
// FlowmapAddUV


void flow_map_add_uv(in vec3 uv, in float uv_scale, in vec3 layer1, in vec3 layer2, out vec3 uv1, out vec3 uv2) {
	vec3 uv_data = uv * uv_scale;
	uv1 = layer1 + uv_data;
	uv2 = layer2 + uv_data;
}

void vertex() {
// Output:0

}

void fragment() {
// Color:14
	vec3 n_out14p0 = vec3(0.000000, 0.462745, 0.690196);
	float n_out14p1 = 0.960784;

// Scalar:13
	float n_out13p0 = 0.000000;

// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// Texture:5
	vec4 tex_frg_5_read = texture(tex_frg_5, UV.xy);
	vec3 n_out5p0 = tex_frg_5_read.rgb;
	float n_out5p1 = tex_frg_5_read.a;

// VectorCompose:10
	float n_in10p0 = 1.00000;
	float n_in10p1 = -1.00000;
	float n_in10p2 = 0.00000;
	vec3 n_out10p0 = vec3(n_in10p0, n_in10p1, n_in10p2);

// Flowmap:2
	float n_in2p1 = 5.00000;
	float n_in2p2 = 0.50000;
	float n_in2p5 = 0.00000;
	float n_out2p0;
	vec3 n_out2p1;
	vec3 n_out2p2;
	float n_out2p3;
	{
		flow_map(n_out5p0, n_in2p1, n_in2p2, n_out4p0, n_out10p0, n_in2p5, TIME, n_out2p0, n_out2p1, n_out2p2, n_out2p3);
	}

// FlowmapAddUV:3
	float n_in3p1 = 5.00000;
	vec3 n_out3p0;
	vec3 n_out3p1;
	{
		flow_map_add_uv(n_out4p0, n_in3p1, n_out2p1, n_out2p2, n_out3p0, n_out3p1);
	}

// Texture:6
	vec4 tex_frg_6_read = texture(tex_frg_6, n_out3p0.xy);
	vec3 n_out6p0 = tex_frg_6_read.rgb;
	float n_out6p1 = tex_frg_6_read.a;

// Texture:7
	vec4 tex_frg_7_read = texture(tex_frg_7, n_out3p1.xy);
	vec3 n_out7p0 = tex_frg_7_read.rgb;
	float n_out7p1 = tex_frg_7_read.a;

// VectorScalarMix:9
	vec3 n_out9p0 = mix(n_out6p0, n_out7p0, n_out2p0);

// Scalar:15
	float n_out15p0 = 0.300000;

// Output:0
	ALBEDO = n_out14p0;
	ALPHA = n_out14p1;
	ROUGHNESS = n_out13p0;
	NORMALMAP = n_out9p0;
	NORMALMAP_DEPTH = n_out15p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -1237.68, 131.2 )
nodes/fragment/0/position = Vector2( 780, 0 )
nodes/fragment/2/node = SubResource( 157 )
nodes/fragment/2/position = Vector2( -341, 300 )
nodes/fragment/3/node = SubResource( 158 )
nodes/fragment/3/position = Vector2( -41, 260 )
nodes/fragment/4/node = SubResource( 159 )
nodes/fragment/4/position = Vector2( -580, 100 )
nodes/fragment/5/node = SubResource( 160 )
nodes/fragment/5/position = Vector2( -620, 180 )
nodes/fragment/6/node = SubResource( 161 )
nodes/fragment/6/position = Vector2( 240, 60 )
nodes/fragment/7/node = SubResource( 162 )
nodes/fragment/7/position = Vector2( 240, 280 )
nodes/fragment/9/node = SubResource( 163 )
nodes/fragment/9/position = Vector2( 480, 240 )
nodes/fragment/10/node = SubResource( 153 )
nodes/fragment/10/position = Vector2( -600, 420 )
nodes/fragment/13/node = SubResource( 154 )
nodes/fragment/13/position = Vector2( 520, 80 )
nodes/fragment/14/node = SubResource( 155 )
nodes/fragment/14/position = Vector2( 560, -20 )
nodes/fragment/15/node = SubResource( 156 )
nodes/fragment/15/position = Vector2( 500, 380 )
nodes/fragment/connections = PoolIntArray( 2, 1, 3, 2, 2, 2, 3, 3, 4, 0, 2, 3, 5, 0, 2, 0, 10, 0, 2, 4, 4, 0, 3, 0, 2, 0, 9, 2, 3, 1, 7, 0, 3, 0, 6, 0, 7, 0, 9, 1, 6, 0, 9, 0, 13, 0, 0, 3, 9, 0, 0, 8, 15, 0, 0, 9, 14, 0, 0, 0, 14, 1, 0, 1 )

[sub_resource type="ShaderMaterial" id=165]
shader = SubResource( 164 )

[sub_resource type="InputEventAction" id=166]
action = "ui_left"

[sub_resource type="ShortCut" id=167]
shortcut = SubResource( 166 )

[sub_resource type="InputEventAction" id=168]
action = "ui_right"

[sub_resource type="ShortCut" id=169]
shortcut = SubResource( 168 )

[sub_resource type="VisualShaderNodeCustom" id=170]
script = ExtResource( 23 )

[sub_resource type="VisualShaderNodeCustom" id=171]
default_input_values = [ 1, 0.05, 2, 0.0, 4, 1.0 ]
script = ExtResource( 4 )

[sub_resource type="VisualShaderNodeCustom" id=172]
default_input_values = [ 1, 5.0, 2, 1.0, 5, 0.0 ]
script = ExtResource( 22 )

[sub_resource type="VisualShaderNodeCustom" id=173]
default_input_values = [ 1, 1.0 ]
script = ExtResource( 21 )

[sub_resource type="VisualShaderNodeCustom" id=174]
script = ExtResource( 11 )

[sub_resource type="VisualShaderNodeCustom" id=175]
default_input_values = [ 1, 0.0 ]
script = ExtResource( 20 )

[sub_resource type="VisualShaderNodeCustom" id=176]
default_input_values = [ 2, 0.05, 3, 8, 4, 32, 9, Vector2( 1, 1 ) ]
script = ExtResource( 12 )

[sub_resource type="VisualShaderNodeCustom" id=177]
default_input_values = [ 2, 0.05, 9, Vector2( 1, 1 ) ]
script = ExtResource( 19 )

[sub_resource type="VisualShaderNodeCustom" id=178]
script = ExtResource( 10 )

[sub_resource type="VisualShaderNodeCustom" id=179]
default_input_values = [ 0, 1.0 ]
script = ExtResource( 9 )

[sub_resource type="VisualShaderNodeCustom" id=180]
default_input_values = [ 2, 1.0 ]
script = ExtResource( 2 )

[sub_resource type="VisualShaderNodeCustom" id=181]
default_input_values = [ 2, 1.0 ]
script = ExtResource( 3 )

[sub_resource type="VisualShaderNodeCustom" id=182]
default_input_values = [ 0, 0, 1, 10 ]
script = ExtResource( 8 )

[sub_resource type="VisualShaderNodeCustom" id=183]
default_input_values = [ 0, 1.0 ]
script = ExtResource( 15 )

[sub_resource type="VisualShader" id=184]
nodes/fragment/0/position = Vector2( 980, 300 )
nodes/fragment/2/node = SubResource( 176 )
nodes/fragment/2/position = Vector2( 40, 40 )
nodes/fragment/3/node = SubResource( 177 )
nodes/fragment/3/position = Vector2( 320, 40 )
nodes/fragment/4/node = SubResource( 178 )
nodes/fragment/4/position = Vector2( 580, 360 )
nodes/fragment/5/node = SubResource( 179 )
nodes/fragment/5/position = Vector2( 580, 280 )
nodes/fragment/6/node = SubResource( 180 )
nodes/fragment/6/position = Vector2( 40, 340 )
nodes/fragment/7/node = SubResource( 181 )
nodes/fragment/7/position = Vector2( 40, 460 )
nodes/fragment/8/node = SubResource( 182 )
nodes/fragment/8/position = Vector2( 580, 40 )
nodes/fragment/9/node = SubResource( 183 )
nodes/fragment/9/position = Vector2( 580, 160 )
nodes/fragment/10/node = SubResource( 170 )
nodes/fragment/10/position = Vector2( 580, 440 )
nodes/fragment/11/node = SubResource( 171 )
nodes/fragment/11/position = Vector2( 280, 280 )
nodes/fragment/12/node = SubResource( 172 )
nodes/fragment/12/position = Vector2( 40, 600 )
nodes/fragment/13/node = SubResource( 173 )
nodes/fragment/13/position = Vector2( 320, 640 )
nodes/fragment/14/node = SubResource( 174 )
nodes/fragment/14/position = Vector2( 320, 500 )
nodes/fragment/15/node = SubResource( 175 )
nodes/fragment/15/position = Vector2( 580, 520 )

[sub_resource type="ShaderMaterial" id=185]
shader = SubResource( 184 )

[node name="MaterialTester" type="Spatial"]
script = ExtResource( 18 )

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = ExtResource( 1 )

[node name="Testers" type="Spatial" parent="."]

[node name="Deep Parallax (Depth)" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -42, 0, 0 )

[node name="MeshInstance6" type="MeshInstance" parent="Testers/Deep Parallax (Depth)"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.32702, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 64 )

[node name="Emission" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -36, 0, 0 )

[node name="SpotLight" parent="Testers/Emission" index="2"]
light_energy = 0.0

[node name="MeshInstance4" type="MeshInstance" parent="Testers/Emission"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.32702, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 69 )

[node name="Refraction" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -30, 0, 0 )

[node name="MeshInstance5" type="MeshInstance" parent="Testers/Refraction"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.32702, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 78 )

[node name="Screen Space Refraction" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -24, 0, 0 )

[node name="MeshInstance4" type="MeshInstance" parent="Testers/Screen Space Refraction"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.32702, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 89 )

[node name="Pixel Dither" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -18, 0, 0 )

[node name="MeshInstance6" type="MeshInstance" parent="Testers/Pixel Dither"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.32702, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 90 )

[node name="Proximity Fade" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -12, 0, 0 )

[node name="MeshInstance3" type="MeshInstance" parent="Testers/Proximity Fade"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.69747, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 102 )

[node name="Proximity Fade Dither" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, -6, 0, 0 )

[node name="MeshInstance4" type="MeshInstance" parent="Testers/Proximity Fade Dither"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.69747, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 112 )

[node name="Distance Fade (Zoom in and out)" parent="Testers" instance=ExtResource( 17 )]

[node name="MeshInstance3" type="MeshInstance" parent="Testers/Distance Fade (Zoom in and out)"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.69747, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 118 )

[node name="Distance Fade Pixel Dither (Zoom in and out)" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 6, 0, 0 )

[node name="MeshInstance4" type="MeshInstance" parent="Testers/Distance Fade Pixel Dither (Zoom in and out)"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.69747, -4 )
mesh = SubResource( 47 )
material/0 = SubResource( 125 )

[node name="Rotation Around origin (local)" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 12, 0, 0 )

[node name="MeshInstance4" type="MeshInstance" parent="Testers/Rotation Around origin (local)"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.69747, -4 )
mesh = SubResource( 126 )
material/0 = SubResource( 138 )

[node name="Rotation Around Pivot (local)" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0 )

[node name="MeshInstance4" type="MeshInstance" parent="Testers/Rotation Around Pivot (local)"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.69747, -4 )
mesh = SubResource( 126 )
material/0 = SubResource( 151 )

[node name="Flowmap UV Animation" parent="Testers" instance=ExtResource( 17 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 24, 0, 0 )

[node name="terrain" parent="Testers/Flowmap UV Animation" instance=ExtResource( 25 )]
transform = Transform( 0.04, 0, 0, 0, 0.04, -2.45869e-08, 0, 2.45869e-08, 0.04, 0, 2.69747, -4 )

[node name="MeshInstance4" type="MeshInstance" parent="Testers/Flowmap UV Animation"]
transform = Transform( 1.6, 0, 0, 0, 1.6, 9.53674e-08, 0, -9.53674e-08, 1.6, 0, 2.70468, -4 )
mesh = SubResource( 152 )
material/0 = SubResource( 165 )

[node name="CameraHolder" type="Spatial" parent="."]
transform = Transform( 0.877582, 0, -0.479427, 0, 1, 0, 0.479427, 0, 0.877582, -36, 2.8, -4 )

[node name="RotationX" type="Spatial" parent="CameraHolder"]
transform = Transform( 1, 0, 0, 0, 0.877582, 0.479427, 0, -0.479427, 0.877582, 0, 0, 0 )

[node name="Camera" type="Camera" parent="CameraHolder/RotationX"]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 5 )
fov = 65.0
near = 0.1

[node name="UI" type="Control" parent="."]
anchor_right = 1.0
anchor_bottom = 1.0
mouse_filter = 2
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Previous" type="Button" parent="UI"]
anchor_top = 1.0
anchor_bottom = 1.0
margin_left = 30.0
margin_top = -50.0
margin_right = 97.0
margin_bottom = -30.0
shortcut = SubResource( 167 )
text = "Previous"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Next" type="Button" parent="UI"]
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
margin_left = -72.0
margin_top = -50.0
margin_right = -30.0
margin_bottom = -30.0
shortcut = SubResource( 169 )
text = "Next"

[node name="MaterialName" type="Label" parent="UI"]
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
margin_left = -250.0
margin_top = -44.0
margin_right = 250.0
margin_bottom = -30.0
rect_min_size = Vector2( 500, 0 )
size_flags_vertical = 0
align = 1
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Node Overview" type="MeshInstance" parent="."]
material_override = SubResource( 185 )
[connection signal="pressed" from="UI/Previous" to="." method="_on_Previous_pressed"]
[connection signal="pressed" from="UI/Next" to="." method="_on_Next_pressed"]

[editable path="Testers/Emission"]
